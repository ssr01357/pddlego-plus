Observations: You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
To the South you see a closed patio door. To the West you see a closed plain door.  
Gold path: ['look around', 'open door to south', 'open door to west', 'move south', 'open door to west', 'move east', 'open door to north', 'move north', 'take coin'] 
Valid Actions: ['look around', 'close door to west', 'move west', 'open door to south', 'open door to west', 'inventory', 'move south', 'close door to south'] 
taskDescription: Your task is to search the environment and find the coin.  Once you find the coin, take it. 
brief_obs: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 
 


====Step 0==== 

----Larger Loop No. 0---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Door, Room)
    def move_south(self, current, door, target):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: the current kitchen and two potential unexplored rooms (south and west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "room_south", "room_west"])
        # Define doors observed in the kitchen
        self.sDoorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["plain_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["kitchen"]),
            self.closed(self.sDoorObjs["patio_door"]),
            self.closed(self.wDoorObjs["plain_door"]),
            self.south_door(self.sDoorObjs["patio_door"]),
            self.west_door(self.wDoorObjs["plain_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # Goal: move to a new location (here, the room to the south) which has not been visited yet
        goal_state = [
            self.at(self.roomObjs["room_south"])
        ]
        return goal_state

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
N/A

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Door, Room)
    def move_south(self, current, door, target):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: the current kitchen and two potential unexplored rooms (south and west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "room_south", "room_west"])
        # Define doors observed in the kitchen
        self.sDoorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["plain_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["kitchen"]),
            self.closed(self.sDoorObjs["patio_door"]),
            self.closed(self.wDoorObjs["plain_door"]),
            self.south_door(self.sDoorObjs["patio_door"]),
            self.west_door(self.wDoorObjs["plain_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # Goal: move to a new location (here, the room to the south) which has not been visited yet
        goal_state = [
            self.at(self.roomObjs["room_south"])
        ]
        return goal_state

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2) (not (door_closed ?loc1 ?dir ?loc2)))
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to) (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen room_south room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (door_closed kitchen south room_south)
    (door_closed kitchen west room_west)
  )
  (:goal (at room_south))
)
Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR KITCHEN ROOM_SOUTH SOUTH)
(MOVE KITCHEN ROOM_SOUTH SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 4
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000131
Nodes generated during search: 6
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000131 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_9kw60fpz/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_9kw60fpz/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the patio door, revealing the backyard.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 1==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Door, Room)
    def move_south(self, current, door, target):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: the current kitchen and two potential unexplored rooms (south and west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "room_south", "room_west"])
        # Define doors observed in the kitchen
        self.sDoorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["plain_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["kitchen"]),
            self.closed(self.sDoorObjs["patio_door"]),
            self.closed(self.wDoorObjs["plain_door"]),
            self.south_door(self.sDoorObjs["patio_door"]),
            self.west_door(self.wDoorObjs["plain_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # Goal: move to a new location (here, the room to the south) which has not been visited yet
        goal_state = [
            self.at(self.roomObjs["room_south"])
        ]
        return goal_state

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2) (not (door_closed ?loc1 ?dir ?loc2)))
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to) (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen room_south room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (door_closed kitchen south room_south)
    (door_closed kitchen west room_west)
  )
  (:goal (at room_south))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Door, Room)
    def move_south(self, current, door, target):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms: the previously visited kitchen, the current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # 'patio_door' was opened to go from kitchen to backyard and is still open (modeled here with south_door predicate)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # In the backyard, a door to the South (leading to the driveway) is observed (initially closed)
        self.sDoorObjs = ExplorationDomain.Door.create_objs(["backyard_south_door"])
        
        # Also in the backyard, a door to the West (a closed patio door) is observed (initially closed)
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        
    @init
    def init(self):
        init_state = [
            # The agent is currently in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # The patio door (connecting kitchen and backyard) is open and marked as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # The door to the south from backyard (leading to the driveway) is currently closed
            self.closed(self.sDoorObjs["backyard_south_door"]),
            self.south_door(self.sDoorObjs["backyard_south_door"]),
            
            # The door to the west from backyard (leading to an unexplored area) is currently closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # The exploration goal is to move into an unexplored location. Here, the driveway (to the south) is chosen as the goal.
        goal_state = [
            self.at(self.roomObjs["driveway"])
        ]
        return goal_state


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2) (not (door_closed ?loc1 ?dir ?loc2)))
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to) (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen room_south room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (door_closed kitchen south room_south)
    (door_closed kitchen west room_west)
  )
  (:goal (at room_south))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Door, Room)
    def move_south(self, current, door, target):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms: the previously visited kitchen, the current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # 'patio_door' was opened to go from kitchen to backyard and is still open (modeled here with south_door predicate)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # In the backyard, a door to the South (leading to the driveway) is observed (initially closed)
        self.sDoorObjs = ExplorationDomain.Door.create_objs(["backyard_south_door"])
        
        # Also in the backyard, a door to the West (a closed patio door) is observed (initially closed)
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        
    @init
    def init(self):
        init_state = [
            # The agent is currently in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # The patio door (connecting kitchen and backyard) is open and marked as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # The door to the south from backyard (leading to the driveway) is currently closed
            self.closed(self.sDoorObjs["backyard_south_door"]),
            self.south_door(self.sDoorObjs["backyard_south_door"]),
            
            # The door to the west from backyard (leading to an unexplored area) is currently closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # The exploration goal is to move into an unexplored location. Here, the driveway (to the south) is chosen as the goal.
        goal_state = [
            self.at(self.roomObjs["driveway"])
        ]
        return goal_state


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2) (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to) (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard south driveway)
    (door_closed backyard west room_west)
  )
  (:goal (at driveway))
)
Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR BACKYARD DRIVEWAY SOUTH)
(MOVE BACKYARD DRIVEWAY SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 4
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000111
Nodes generated during search: 6
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000111 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_y05b9n9j/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_y05b9n9j/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Door, Room)
    def move_south(self, current, door, target):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms: the previously visited kitchen, the current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # 'patio_door' was opened to go from kitchen to backyard and is still open (modeled here with south_door predicate)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # In the backyard, a door to the South (leading to the driveway) is observed (initially closed)
        self.sDoorObjs = ExplorationDomain.Door.create_objs(["backyard_south_door"])
        
        # Also in the backyard, a door to the West (a closed patio door) is observed (initially closed)
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        
    @init
    def init(self):
        init_state = [
            # The agent is currently in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # The patio door (connecting kitchen and backyard) is open and marked as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # The door to the south from backyard (leading to the driveway) is currently closed
            self.closed(self.sDoorObjs["backyard_south_door"]),
            self.south_door(self.sDoorObjs["backyard_south_door"]),
            
            # The door to the west from backyard (leading to an unexplored area) is currently closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # The exploration goal is to move into an unexplored location. Here, the driveway (to the south) is chosen as the goal.
        goal_state = [
            self.at(self.roomObjs["driveway"])
        ]
        return goal_state


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2) (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to) (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard south driveway)
    (door_closed backyard west room_west)
  )
  (:goal (at driveway))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    # Updated move_south action to support direct movement when no door exists to the south
    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms: a visited kitchen, the current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # 'patio_door' connects kitchen and backyard and is open (and marked as a south door)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # The door to the west from backyard exists and is closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        
        # Note: No south door is created because the observation indicates that in the south there is no door
        
    @init
    def init(self):
        init_state = [
            # Agent is in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # Patio door between kitchen and backyard is open and serves as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door from backyard is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # The exploration goal is to visit the unexplored location to the south (driveway),
        # which can be reached directly since no door exists in that direction.
        goal_state = [
            self.at(self.roomObjs["driveway"])
        ]
        return goal_state


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2) (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to) (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard south driveway)
    (door_closed backyard west room_west)
  )
  (:goal (at driveway))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    # Updated move_south action to support direct movement when no door exists to the south
    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms: a visited kitchen, the current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # 'patio_door' connects kitchen and backyard and is open (and marked as a south door)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # The door to the west from backyard exists and is closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        
        # Note: No south door is created because the observation indicates that in the south there is no door
        
    @init
    def init(self):
        init_state = [
            # Agent is in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # Patio door between kitchen and backyard is open and serves as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door from backyard is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # The exploration goal is to visit the unexplored location to the south (driveway),
        # which can be reached directly since no door exists in that direction.
        goal_state = [
            self.at(self.roomObjs["driveway"])
        ]
        return goal_state


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at driveway))
)
Actions from solver: ['move west'] 
Raw plan text: (MOVE BACKYARD DRIVEWAY WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 26 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 26
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000106
Nodes generated during search: 5
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000106 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_o7e14a6g/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_o7e14a6g/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 You can't move there, the door is closed.  
Large loop error message: This is the action you take: move west. The door that you are moving to is closed. You should first open door to that direction then move there! 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You can't move there, the door is closed. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    # Updated move_south action to support direct movement when no door exists to the south
    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms: a visited kitchen, the current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # 'patio_door' connects kitchen and backyard and is open (and marked as a south door)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # The door to the west from backyard exists and is closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        
        # Note: No south door is created because the observation indicates that in the south there is no door
        
    @init
    def init(self):
        init_state = [
            # Agent is in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # Patio door between kitchen and backyard is open and serves as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door from backyard is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # The exploration goal is to visit the unexplored location to the south (driveway),
        # which can be reached directly since no door exists in that direction.
        goal_state = [
            self.at(self.roomObjs["driveway"])
        ]
        return goal_state


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at driveway))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: move west. The door that you are moving to is closed. You should first open door to that direction then move there!

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: visited kitchen, current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # Patio door connects kitchen and backyard and is open (marked as a south door)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door from backyard exists but is closed, as observed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # Patio door is open and serves as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door is closed though it exists as a west door
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The intended exploration target is the unvisited room to the west.
        goal_state = [
            self.at(self.roomObjs["room_west"])
        ]
        return goal_state

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You can't move there, the door is closed. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at driveway))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move west. The door that you are moving to is closed. You should first open door to that direction then move there!

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: visited kitchen, current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # Patio door connects kitchen and backyard and is open (marked as a south door)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door from backyard exists but is closed, as observed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # Patio door is open and serves as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door is closed though it exists as a west door
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The intended exploration target is the unvisited room to the west.
        goal_state = [
            self.at(self.roomObjs["room_west"])
        ]
        return goal_state

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
Actions from solver: ['move south'] 
Raw plan text: (MOVE BACKYARD ROOM_WEST SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 26 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 26
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000123
Nodes generated during search: 5
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000123 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_88oyj9pe/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_88oyj9pe/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 2==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: visited kitchen, current backyard, and two unexplored locations: driveway (south) and room_west (west)
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on observations
        # Patio door connects kitchen and backyard and is open (marked as a south door)
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door from backyard exists but is closed, as observed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts in the backyard
            self.at(self.roomObjs["backyard"]),
            
            # Patio door is open and serves as a south door
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door is closed though it exists as a west door
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The intended exploration target is the unvisited room to the west.
        goal_state = [
            self.at(self.roomObjs["room_west"])
        ]
        return goal_state

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    # New predicate to capture the observation that from the current room the neighbor to the north is visible
    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: visited kitchen, visited backyard, and two unexplored locations: driveway and room_west
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on previous observations
        # Patio door connects kitchen and backyard and is marked as a south door
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door from backyard exists but is currently closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Updated current location: the agent moved south and is now in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # Existing door states from previous observations
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # New observation: from the driveway, the backyard is visible to the north
            self.north_view(self.roomObjs["driveway"], self.roomObjs["backyard"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # Goal: Explore new unvisited location (room_west remains unvisited)
        goal_state = [
            self.at(self.roomObjs["room_west"])
        ]
        return goal_state

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open kitchen south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    # New predicate to capture the observation that from the current room the neighbor to the north is visible
    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: visited kitchen, visited backyard, and two unexplored locations: driveway and room_west
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on previous observations
        # Patio door connects kitchen and backyard and is marked as a south door
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door from backyard exists but is currently closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Updated current location: the agent moved south and is now in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # Existing door states from previous observations
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # New observation: from the driveway, the backyard is visible to the north
            self.north_view(self.roomObjs["driveway"], self.roomObjs["backyard"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # Goal: Explore new unvisited location (room_west remains unvisited)
        goal_state = [
            self.at(self.roomObjs["room_west"])
        ]
        return goal_state

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west north - direction
  )
  (:init
    (at driveway)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
    (north_view driveway backyard)
  )
  (:goal (at room_west))
)
Actions from solver: ['move north'] 
Raw plan text: (MOVE DRIVEWAY ROOM_WEST NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 38 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 38
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000111
Nodes generated during search: 5
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000111 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_wlhi_djh/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_wlhi_djh/plan_tmp.txt 1

Current action_queue: ['move north'] 
> move north 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 3==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    # New predicate to capture the observation that from the current room the neighbor to the north is visible
    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: visited kitchen, visited backyard, and two unexplored locations: driveway and room_west
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west"])
        
        # Define door objects based on previous observations
        # Patio door connects kitchen and backyard and is marked as a south door
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door from backyard exists but is currently closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Updated current location: the agent moved south and is now in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # Existing door states from previous observations
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # New observation: from the driveway, the backyard is visible to the north
            self.north_view(self.roomObjs["driveway"], self.roomObjs["backyard"])
        ]
        return init_state
    
    @goal
    def goal(self):
        # Goal: Explore new unvisited location (room_west remains unvisited)
        goal_state = [
            self.at(self.roomObjs["room_west"])
        ]
        return goal_state

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west north - direction
  )
  (:init
    (at driveway)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
    (north_view driveway backyard)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    # Added to capture the observation: to the East you see the street
    @predicate(Room, Room)
    def east_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: kitchen, backyard, driveway, an unexplored room to the west, and street observed to the east
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        
        # Define door objects for manipulable doors
        # The south door (connecting backyard and driveway) can be opened or closed
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # The west door from backyard is observed as closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the backyard after executing move north
            self.at(self.roomObjs["backyard"]),
            
            # South door (to the driveway) is open and manipulable
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door (to room_west) is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # From the backyard, an open view to the north shows the kitchen through a patio door
            self.north_view(self.roomObjs["backyard"], self.roomObjs["kitchen"]),
            
            # From the backyard, the street is visible to the east
            self.east_view(self.roomObjs["backyard"], self.roomObjs["street"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: move to an unexplored location; here, room_west remains unvisited
        return [self.at(self.roomObjs["room_west"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west - location
    south west north - direction
  )
  (:init
    (at driveway)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
    (north_view driveway backyard)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    # Added to capture the observation: to the East you see the street
    @predicate(Room, Room)
    def east_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: kitchen, backyard, driveway, an unexplored room to the west, and street observed to the east
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        
        # Define door objects for manipulable doors
        # The south door (connecting backyard and driveway) can be opened or closed
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # The west door from backyard is observed as closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the backyard after executing move north
            self.at(self.roomObjs["backyard"]),
            
            # South door (to the driveway) is open and manipulable
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door (to room_west) is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # From the backyard, an open view to the north shows the kitchen through a patio door
            self.north_view(self.roomObjs["backyard"], self.roomObjs["kitchen"]),
            
            # From the backyard, the street is visible to the east
            self.east_view(self.roomObjs["backyard"], self.roomObjs["street"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: move to an unexplored location; here, room_west remains unvisited
        return [self.at(self.roomObjs["room_west"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
    (east_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west north east - direction
  )
  (:init
    (at backyard)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
    (north_view backyard kitchen)
    (east_view backyard street)
  )
  (:goal (at room_west))
)
Actions from solver: ['move east'] 
Raw plan text: (MOVE BACKYARD ROOM_WEST EAST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 82 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 82
	#Fluents: 8
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000119
Nodes generated during search: 6
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000119 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_1jj1q3n9/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_1jj1q3n9/plan_tmp.txt 1

Current action_queue: ['move east'] 
> move east 
 You are in the street. 
To the North you see a closed sliding door. To the West you see the backyard.  


====Step 4==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the street. To the North you see a closed sliding door. To the West you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    # Added to capture the observation: to the East you see the street
    @predicate(Room, Room)
    def east_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define rooms: kitchen, backyard, driveway, an unexplored room to the west, and street observed to the east
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        
        # Define door objects for manipulable doors
        # The south door (connecting backyard and driveway) can be opened or closed
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # The west door from backyard is observed as closed
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the backyard after executing move north
            self.at(self.roomObjs["backyard"]),
            
            # South door (to the driveway) is open and manipulable
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door (to room_west) is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # From the backyard, an open view to the north shows the kitchen through a patio door
            self.north_view(self.roomObjs["backyard"], self.roomObjs["kitchen"]),
            
            # From the backyard, the street is visible to the east
            self.east_view(self.roomObjs["backyard"], self.roomObjs["street"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: move to an unexplored location; here, room_west remains unvisited
        return [self.at(self.roomObjs["room_west"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
    (east_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west north east - direction
  )
  (:init
    (at backyard)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
    (north_view backyard kitchen)
    (east_view backyard street)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    @predicate(Room, Room)
    def east_view(self, current, neighbor):
        pass

    @predicate(Door)
    def north_door(self, door):
        pass

    @predicate(Room, Room)
    def west_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        self.nDoorObjs = ExplorationDomain.Door.create_objs(["street_north_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the street after executing move east
            self.at(self.roomObjs["street"]),
            
            # South door (patio door) remains open for passage
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door from the backyard side is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # Observations from street: a closed sliding door to the north
            self.north_door(self.nDoorObjs["street_north_door"]),
            self.closed(self.nDoorObjs["street_north_door"]),
            
            # From street, the backyard is visible to the west
            self.west_view(self.roomObjs["street"], self.roomObjs["backyard"]),
            
            # Maintain the relation that from backyard, street is visible to the east
            self.east_view(self.roomObjs["backyard"], self.roomObjs["street"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: Go to an unexplored location; here, room_west remains unvisited
        return [self.at(self.roomObjs["room_west"])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the street. To the North you see a closed sliding door. To the West you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
    (east_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west north east - direction
  )
  (:init
    (at backyard)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
    (north_view backyard kitchen)
    (east_view backyard street)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    @predicate(Room, Room)
    def east_view(self, current, neighbor):
        pass

    @predicate(Door)
    def north_door(self, door):
        pass

    @predicate(Room, Room)
    def west_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        self.nDoorObjs = ExplorationDomain.Door.create_objs(["street_north_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the street after executing move east
            self.at(self.roomObjs["street"]),
            
            # South door (patio door) remains open for passage
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door from the backyard side is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # Observations from street: a closed sliding door to the north
            self.north_door(self.nDoorObjs["street_north_door"]),
            self.closed(self.nDoorObjs["street_north_door"]),
            
            # From street, the backyard is visible to the west
            self.west_view(self.roomObjs["street"], self.roomObjs["backyard"]),
            
            # Maintain the relation that from backyard, street is visible to the east
            self.east_view(self.roomObjs["backyard"], self.roomObjs["street"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: Go to an unexplored location; here, room_west remains unvisited
        return [self.at(self.roomObjs["room_west"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
    (east_view ?from - location ?to - location)
    (west_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west north east - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
    (door_closed street west backyard)
    (door_closed street north kitchen)
    (west_view street backyard)
    (north_view street kitchen)
    (door_closed backyard west room_west)
    (east_view backyard street)
  )
  (:goal (at room_west))
)
Actions from solver: ['move east'] 
Raw plan text: (MOVE STREET ROOM_WEST EAST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 86 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 86
	#Fluents: 14
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 9.79999e-05
Nodes generated during search: 8
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 9.79999e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_bg849qe2/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_bg849qe2/plan_tmp.txt 1

Current action_queue: ['move east'] 
> move east 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move east. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @predicate(Room, Room)
    def north_view(self, current, neighbor):
        pass

    @predicate(Room, Room)
    def east_view(self, current, neighbor):
        pass

    @predicate(Door)
    def north_door(self, door):
        pass

    @predicate(Room, Room)
    def west_view(self, current, neighbor):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.patio_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.wDoorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])
        self.nDoorObjs = ExplorationDomain.Door.create_objs(["street_north_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the street after executing move east
            self.at(self.roomObjs["street"]),
            
            # South door (patio door) remains open for passage
            self.open(self.patio_doorObjs["patio_door"]),
            self.south_door(self.patio_doorObjs["patio_door"]),
            
            # West door from the backyard side is closed
            self.closed(self.wDoorObjs["backyard_west_door"]),
            self.west_door(self.wDoorObjs["backyard_west_door"]),
            
            # Observations from street: a closed sliding door to the north
            self.north_door(self.nDoorObjs["street_north_door"]),
            self.closed(self.nDoorObjs["street_north_door"]),
            
            # From street, the backyard is visible to the west
            self.west_view(self.roomObjs["street"], self.roomObjs["backyard"]),
            
            # Maintain the relation that from backyard, street is visible to the east
            self.east_view(self.roomObjs["backyard"], self.roomObjs["street"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: Go to an unexplored location; here, room_west remains unvisited
        return [self.at(self.roomObjs["room_west"])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
    (east_view ?from - location ?to - location)
    (west_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west north east - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
    (door_closed street west backyard)
    (door_closed street north kitchen)
    (west_view street backyard)
    (north_view street kitchen)
    (door_closed backyard west room_west)
    (east_view backyard street)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: move east. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["street"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["backyard_west_door"]),
            self.west_door(self.west_doorObjs["backyard_west_door"])
        ]
        return init_state

    @goal
    def goal(self):
        return [self.at(self.roomObjs["room_west"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
    (north_view ?from - location ?to - location)
    (east_view ?from - location ?to - location)
    (west_view ?from - location ?to - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (door_open ?from ?dir ?to)
                           (not (door_closed ?from ?dir ?to))))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west north east - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
    (door_closed street west backyard)
    (door_closed street north kitchen)
    (west_view street backyard)
    (north_view street kitchen)
    (door_closed backyard west room_west)
    (east_view backyard street)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move east. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["street"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["backyard_west_door"]),
            self.west_door(self.west_doorObjs["backyard_west_door"])
        ]
        return init_state

    @goal
    def goal(self):
        return [self.at(self.roomObjs["room_west"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)


[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
    (door_closed street west backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

Actions from solver: ['open door to west', 'move west', 'open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR STREET BACKYARD WEST)
(MOVE STREET BACKYARD WEST)
(OPEN-DOOR BACKYARD ROOM_WEST WEST)
(MOVE BACKYARD ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 5 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 5
	#Fluents: 8
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[1 / 2]--
--[1 / 3]--
--[0 / 0]--
--[0 / 4]--
Total time: 8.20001e-05
Nodes generated during search: 10
Nodes expanded during search: 8
Plan found with cost: 4
Fast-BFS search completed in 8.20001e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_ojoet8zj/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 4 

Successful plans:
Value: 4
 /tmp/pddl_run_ojoet8zj/plan_tmp.txt 4

Current action_queue: ['open door to west', 'move west', 'open door to west', 'move west'] 
> open door to west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Door, Room)
    def move_west(self, current, door, target):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["backyard_west_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["street"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["backyard_west_door"]),
            self.west_door(self.west_doorObjs["backyard_west_door"])
        ]
        return init_state

    @goal
    def goal(self):
        return [self.at(self.roomObjs["room_west"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)


[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
    (door_closed street west backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    # Updated move_west action with no door requirement, since there is no door in that direction
    @action(Room, Room)
    def move_west(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # Removed west door objects to reflect that there is no door to the west

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["street"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        return [self.at(self.roomObjs["room_west"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)


[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
    (door_closed street west backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    # Updated move_west action with no door requirement, since there is no door in that direction
    @action(Room, Room)
    def move_west(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # Removed west door objects to reflect that there is no door to the west

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["street"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        return [self.at(self.roomObjs["room_west"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
  )
  (:goal (at room_west))
)
Actions from solver: ['move west'] 
Raw plan text: (MOVE STREET ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 40 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 40
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 9.50002e-05
Nodes generated during search: 5
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 9.50002e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_m70zzg2n/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_m70zzg2n/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 5==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room)
    def move_south(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    # Updated move_west action with no door requirement, since there is no door in that direction
    @action(Room, Room)
    def move_west(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "backyard", "driveway", "room_west", "street"])
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # Removed west door objects to reflect that there is no door to the west

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["street"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        return [self.at(self.roomObjs["room_west"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms observed: the backyard (current), kitchen, driveway, street and an unexplored room to the west
        self.roomObjs = ExplorationDomain.Room.create_objs(["backyard", "kitchen", "driveway", "room_west", "street"])
        # South door: connects backyard to driveway and is observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # West door: connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["backyard"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore a new location; here, we set the unexplored room_west as the target
        return [self.at(self.roomObjs["room_west"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at street)
    (door_open street south driveway)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms observed: the backyard (current), kitchen, driveway, street and an unexplored room to the west
        self.roomObjs = ExplorationDomain.Room.create_objs(["backyard", "kitchen", "driveway", "room_west", "street"])
        # South door: connects backyard to driveway and is observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # West door: connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["backyard"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore a new location; here, we set the unexplored room_west as the target
        return [self.at(self.roomObjs["room_west"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)


[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE BACKYARD ROOM_WEST SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 41 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 41
	#Fluents: 8
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 8.30001e-05
Nodes generated during search: 6
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 8.30001e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_fn9moe4f/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_fn9moe4f/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 6==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east', 'move west', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms observed: the backyard (current), kitchen, driveway, street and an unexplored room to the west
        self.roomObjs = ExplorationDomain.Room.create_objs(["backyard", "kitchen", "driveway", "room_west", "street"])
        # South door: connects backyard to driveway and is observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # West door: connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["backyard"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore a new location; here, we set the unexplored room_west as the target
        return [self.at(self.roomObjs["room_west"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)


[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms observed: driveway (current), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        # South door: connects backyard to driveway (used for move south) and is observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # West door: connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["driveway"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; choosing room_west as the target
        return [self.at(self.roomObjs["room_west"])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)


[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway room_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (door_open backyard south driveway)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms observed: driveway (current), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        # South door: connects backyard to driveway (used for move south) and is observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # West door: connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["driveway"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; choosing room_west as the target
        return [self.at(self.roomObjs["room_west"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
Actions from solver: ['move west'] 
Raw plan text: (MOVE DRIVEWAY ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 41 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 41
	#Fluents: 8
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000101
Nodes generated during search: 6
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000101 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_wlt7nwte/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_wlt7nwte/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east', 'move west', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the rooms observed: driveway (current), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        # South door: connects backyard to driveway (used for move south) and is observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        # West door: connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            self.at(self.roomObjs["driveway"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; choosing room_west as the target
        return [self.at(self.roomObjs["room_west"])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        # Note: To move west the agent must be in the room that connects via the west door and the door must be open
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (current), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door: connects driveway and backyard; observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door: connects backyard to the unexplored room_west; observed closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            # West door remains closed, hence move_west cannot be executed until it is opened
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: Explore the unvisited location reachable to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        # Note: To move west the agent must be in the room that connects via the west door and the door must be open
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (current), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door: connects driveway and backyard; observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door: connects backyard to the unexplored room_west; observed closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            # West door remains closed, hence move_west cannot be executed until it is opened
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: Explore the unvisited location reachable to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
Actions from solver: ['move west'] 
Raw plan text: (MOVE DRIVEWAY ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 41 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 41
	#Fluents: 8
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000104
Nodes generated during search: 6
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000104 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_6iya7evl/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_6iya7evl/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east', 'move west', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        # Note: To move west the agent must be in the room that connects via the west door and the door must be open
        precond = [self.at(current), self.west_door(door), ~self.closed(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (current), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door: connects driveway and backyard; observed open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door: connects backyard to the unexplored room_west; observed closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            # West door remains closed, hence move_west cannot be executed until it is opened
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: Explore the unvisited location reachable to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        # To move south the door must be open
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        # To move west, the agent must be in a room connected via the west door and the door must be open
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door: connects driveway and backyard; it is observed to be open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door: connects backyard to the unexplored room_west; it is observed to be closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # The south door is open allowing movement from driveway to backyard
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            
            # The west door remains closed; to move west the agent must first open it
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (not (door_closed ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        # To move south the door must be open
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        # To move west, the agent must be in a room connected via the west door and the door must be open
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door: connects driveway and backyard; it is observed to be open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door: connects backyard to the unexplored room_west; it is observed to be closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # The south door is open allowing movement from driveway to backyard
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            
            # The west door remains closed; to move west the agent must first open it
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
Actions from solver: ['move south', 'open door to west', 'move west'] 
Raw plan text: (MOVE DRIVEWAY BACKYARD SOUTH)
(OPEN-DOOR BACKYARD ROOM_WEST WEST)
(MOVE BACKYARD ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 3 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 3
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[1 / 2]--
--[0 / 0]--
--[0 / 3]--
Total time: 0.000134
Nodes generated during search: 5
Nodes expanded during search: 4
Plan found with cost: 3
Fast-BFS search completed in 0.000134 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_v382dpbz/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 3 

Successful plans:
Value: 3
 /tmp/pddl_run_v382dpbz/plan_tmp.txt 3

Current action_queue: ['move south', 'open door to west', 'move west'] 
> move south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 3---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east', 'move west', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        # To move south the door must be open
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        # To move west, the agent must be in a room connected via the west door and the door must be open
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door: connects driveway and backyard; it is observed to be open
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door: connects backyard to the unexplored room_west; it is observed to be closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # The south door is open allowing movement from driveway to backyard
            self.open(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            
            # The west door remains closed; to move west the agent must first open it
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door (patio_door) connects driveway and backyard; it is now closed so that moving south is not allowed
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door (west_patio_door) connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # South door is closed now; hence, move_south action will fail its precondition until it is opened
            self.closed(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            
            # West door remains closed, requiring it to be opened before moving west
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_open driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door (patio_door) connects driveway and backyard; it is now closed so that moving south is not allowed
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door (west_patio_door) connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # South door is closed now; hence, move_south action will fail its precondition until it is opened
            self.closed(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            
            # West door remains closed, requiring it to be opened before moving west
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_closed driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
Actions from solver: ['open door to west', 'open door to south', 'move south', 'move west'] 
Raw plan text: (OPEN-DOOR BACKYARD ROOM_WEST WEST)
(OPEN-DOOR DRIVEWAY BACKYARD SOUTH)
(MOVE DRIVEWAY BACKYARD SOUTH)
(MOVE BACKYARD ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 4
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[1 / 2]--
--[1 / 3]--
--[0 / 0]--
--[0 / 4]--
Total time: 0.000159
Nodes generated during search: 7
Nodes expanded during search: 6
Plan found with cost: 4
Fast-BFS search completed in 0.000159 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_ap3wnhsu/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 4 

Successful plans:
Value: 4
 /tmp/pddl_run_ap3wnhsu/plan_tmp.txt 4

Current action_queue: ['open door to west', 'open door to south', 'move south', 'move west'] 
> open door to west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 4---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'move east', 'move west', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    @action(Room, Room, Door)
    def move_west(self, current, target, door):
        precond = [self.at(current), self.west_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Rooms observed: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        
        # South door (patio_door) connects driveway and backyard; it is now closed so that moving south is not allowed
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])
        
        # West door (west_patio_door) connects backyard to the unexplored room_west and is currently closed
        self.west_doorObjs = ExplorationDomain.Door.create_objs(["west_patio_door"])

    @init
    def init(self):
        init_state = [
            # The agent starts in the driveway
            self.at(self.roomObjs["driveway"]),
            
            # South door is closed now; hence, move_south action will fail its precondition until it is opened
            self.closed(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"]),
            
            # West door remains closed, requiring it to be opened before moving west
            self.closed(self.west_doorObjs["west_patio_door"]),
            self.west_door(self.west_doorObjs["west_patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west (room_west)
        return [self.at(self.roomObjs["room_west"])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_closed driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    # Updated move_west action because no door exists in the west direction
    @action(Room, Room)
    def move_west(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Observed rooms: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        # Only the south door exists (patio_door) connecting driveway and backyard
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.roomObjs["driveway"]),
            
            # South door (patio_door) is closed initially
            self.closed(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west directly because no door exists on that side
        return [self.at(self.roomObjs["room_west"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door_open ?from ?dir ?to))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_closed driveway south backyard)
    (door_closed backyard west room_west)
  )
  (:goal (at room_west))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")

    @predicate(Room)
    def at(self, room):
        pass

    @predicate(Door)
    def closed(self, door):
        pass

    @predicate(Door)
    def open(self, door):
        pass

    @predicate(Door)
    def south_door(self, door):
        pass

    @predicate(Door)
    def west_door(self, door):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.south_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.west_door(door), self.closed(door)]
        effect = [self.open(door), ~self.closed(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.south_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.west_door(door), self.open(door)]
        effect = [self.closed(door), ~self.open(door)]
        return precond, effect

    @action(Room, Room, Door)
    def move_south(self, current, target, door):
        precond = [self.at(current), self.south_door(door), self.open(door)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect

    # Updated move_west action because no door exists in the west direction
    @action(Room, Room)
    def move_west(self, current, target):
        precond = [self.at(current)]
        effect = [self.at(target), ~self.at(current)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Observed rooms: driveway (starting point), backyard, kitchen, room_west, street
        self.roomObjs = ExplorationDomain.Room.create_objs(["driveway", "backyard", "kitchen", "room_west", "street"])
        # Only the south door exists (patio_door) connecting driveway and backyard
        self.south_doorObjs = ExplorationDomain.Door.create_objs(["patio_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.roomObjs["driveway"]),
            
            # South door (patio_door) is closed initially
            self.closed(self.south_doorObjs["patio_door"]),
            self.south_door(self.south_doorObjs["patio_door"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited room to the west directly because no door exists on that side
        return [self.at(self.roomObjs["room_west"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :equality :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?loc - location)
    (door_closed ?loc1 - location ?dir - direction ?loc2 - location)
    (door_open ?loc1 - location ?dir - direction ?loc2 - location)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door_closed ?loc1 ?dir ?loc2)
    :effect (and (door_open ?loc1 ?dir ?loc2)
                 (not (door_closed ?loc1 ?dir ?loc2)))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from)
                       (or (not (= ?dir south))
                           (door_open ?from ?dir ?to)))
    :effect (and (at ?to)
                 (not (at ?from)))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    driveway backyard kitchen room_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (door_closed driveway south backyard)
  )
  (:goal (at room_west))
)
Actions from solver: ['move west'] 
Raw plan text: (MOVE DRIVEWAY ROOM_WEST WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 22 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 22
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 6e-05
Nodes generated during search: 6
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 6e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_lvyuf_s9/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_lvyuf_s9/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 
