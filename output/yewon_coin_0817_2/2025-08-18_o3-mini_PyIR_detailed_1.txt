Observations: You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
To the South you see a closed patio door. To the West you see a closed plain door.  
Gold path: ['look around', 'open door to south', 'open door to west', 'move south', 'open door to west', 'move north', 'move west', 'move east', 'move south', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'open door to north', 'move north', 'take coin'] 
Valid Actions: ['look around', 'close door to west', 'move west', 'open door to south', 'open door to west', 'inventory', 'move south', 'close door to south'] 
taskDescription: Your task is to search the environment and find the coin.  Once you find the coin, take it. 
brief_obs: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 
 


====Step 0==== 

----Larger Loop No. 0---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Create objects for locations: the observed "kitchen" and the inferred destination "patio"
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "patio"])
        # Create objects for doors as observed: a patio door and a plain door
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        # Create objects for directions: south and west
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["kitchen"]),
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["south"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to a new (not yet visited) location, here represented by 'patio'
        return [self.at(self.locationObjs["patio"])]
--Small Loop--: 0 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
N/A

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Create objects for locations: the observed "kitchen" and the inferred destination "patio"
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "patio"])
        # Create objects for doors as observed: a patio door and a plain door
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        # Create objects for directions: south and west
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["kitchen"]),
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["south"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to a new (not yet visited) location, here represented by 'patio'
        return [self.at(self.locationObjs["patio"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (door ?from - location ?to - location ?dir - direction)
    (door_open ?from - location ?to - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio - location
    south west - direction
  )

  (:init
    (at kitchen)
    (door kitchen patio south)
    (door kitchen kitchen west)
  )

  (:goal (at patio))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR KITCHEN PATIO SOUTH)
(MOVE KITCHEN PATIO SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the patio door, revealing the backyard.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 1==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Create objects for locations: the observed "kitchen" and the inferred destination "patio"
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "patio"])
        # Create objects for doors as observed: a patio door and a plain door
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        # Create objects for directions: south and west
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["kitchen"]),
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["south"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to a new (not yet visited) location, here represented by 'patio'
        return [self.at(self.locationObjs["patio"])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (door ?from - location ?to - location ?dir - direction)
    (door_open ?from - location ?to - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio - location
    south west - direction
  )

  (:init
    (at kitchen)
    (door kitchen patio south)
    (door kitchen kitchen west)
  )

  (:goal (at patio))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: 'kitchen' (already visited), 'backyard' (current location after move south),
        # 'driveway' (observed to the south) and 'unknownWest' (potential room behind the west door)
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "backyard", "driveway", "unknownWest"])
        
        # Define doors: 'patioDoor' (used for south movement) and 'plainDoor' (associated with the west door)
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        
        # Define directions: only the ones relevant for our actions: south and west
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        state = [
            # Agent is now in the backyard after executing move south
            self.at(self.locationObjs["backyard"]),
            # Visited locations
            self.visited(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["backyard"]),
            # Door orientation information
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["south"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"]),
            # The patio door to the south is open as observed
            self.door_open(self.doorObjs["patioDoor"])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to move into a new location; here, the driveway to the south is unvisited
        return [self.at(self.locationObjs["driveway"])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (door ?from - location ?to - location ?dir - direction)
    (door_open ?from - location ?to - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio - location
    south west - direction
  )

  (:init
    (at kitchen)
    (door kitchen patio south)
    (door kitchen kitchen west)
  )

  (:goal (at patio))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: 'kitchen' (already visited), 'backyard' (current location after move south),
        # 'driveway' (observed to the south) and 'unknownWest' (potential room behind the west door)
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "backyard", "driveway", "unknownWest"])
        
        # Define doors: 'patioDoor' (used for south movement) and 'plainDoor' (associated with the west door)
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        
        # Define directions: only the ones relevant for our actions: south and west
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        state = [
            # Agent is now in the backyard after executing move south
            self.at(self.locationObjs["backyard"]),
            # Visited locations
            self.visited(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["backyard"]),
            # Door orientation information
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["south"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"]),
            # The patio door to the south is open as observed
            self.door_open(self.doorObjs["patioDoor"])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to move into a new location; here, the driveway to the south is unvisited
        return [self.at(self.locationObjs["driveway"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (door ?from - location ?to - location ?dir - direction)
    (door_open ?from - location ?to - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west - direction
  )

  (:init
    (at backyard)
    (door backyard driveway south)
    (door_open backyard driveway south)
    (door backyard unknownWest west)
  )

  (:goal (at driveway))
)
Actions from solver(df, pf): ['move south'] 
Raw plan text: (MOVE BACKYARD DRIVEWAY SOUTH)
 
Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 2==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: 'kitchen' (already visited), 'backyard' (current location after move south),
        # 'driveway' (observed to the south) and 'unknownWest' (potential room behind the west door)
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "backyard", "driveway", "unknownWest"])
        
        # Define doors: 'patioDoor' (used for south movement) and 'plainDoor' (associated with the west door)
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        
        # Define directions: only the ones relevant for our actions: south and west
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        state = [
            # Agent is now in the backyard after executing move south
            self.at(self.locationObjs["backyard"]),
            # Visited locations
            self.visited(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["backyard"]),
            # Door orientation information
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["south"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"]),
            # The patio door to the south is open as observed
            self.door_open(self.doorObjs["patioDoor"])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to move into a new location; here, the driveway to the south is unvisited
        return [self.at(self.locationObjs["driveway"])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (door ?from - location ?to - location ?dir - direction)
    (door_open ?from - location ?to - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west - direction
  )

  (:init
    (at backyard)
    (door backyard driveway south)
    (door_open backyard driveway south)
    (door backyard unknownWest west)
  )

  (:goal (at driveway))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "backyard", "driveway", "unknownWest"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west", "north"])

    @init
    def init(self):
        state = [
            # Agent is now in the driveway after executing move south
            self.at(self.locationObjs["driveway"]),
            # Visited locations: kitchen, backyard, and now driveway are visited
            self.visited(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["backyard"]),
            self.visited(self.locationObjs["driveway"]),
            # Door orientation: from driveway, the patioDoor is observed towards the north (leading to backyard)
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["north"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"]),
            # The patio door is open as observed
            self.door_open(self.doorObjs["patioDoor"])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach an unvisited location, here unknownWest is unvisited
        return [self.at(self.locationObjs["unknownWest"])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (door ?from - location ?to - location ?dir - direction)
    (door_open ?from - location ?to - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west - direction
  )

  (:init
    (at backyard)
    (door backyard driveway south)
    (door_open backyard driveway south)
    (door backyard unknownWest west)
  )

  (:goal (at driveway))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "backyard", "driveway", "unknownWest"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west", "north"])

    @init
    def init(self):
        state = [
            # Agent is now in the driveway after executing move south
            self.at(self.locationObjs["driveway"]),
            # Visited locations: kitchen, backyard, and now driveway are visited
            self.visited(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["backyard"]),
            self.visited(self.locationObjs["driveway"]),
            # Door orientation: from driveway, the patioDoor is observed towards the north (leading to backyard)
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["north"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"]),
            # The patio door is open as observed
            self.door_open(self.doorObjs["patioDoor"])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach an unvisited location, here unknownWest is unvisited
        return [self.at(self.locationObjs["unknownWest"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
    (door driveway unknownWest west)
  )

  (:goal (at unknownWest))
)
Actions from solver(df, pf): ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR DRIVEWAY UNKNOWNWEST WEST)
(MOVE DRIVEWAY UNKNOWNWEST WEST)
 
Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type("Location")
    Door = create_type("Door")
    Direction = create_type("Direction")
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, "south"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, "west"), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, "south"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, "west"), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "south"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, "west"), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(["kitchen", "backyard", "driveway", "unknownWest"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["patioDoor", "plainDoor"])
        self.directionObjs = ExplorationDomain.Direction.create_objs(["south", "west", "north"])

    @init
    def init(self):
        state = [
            # Agent is now in the driveway after executing move south
            self.at(self.locationObjs["driveway"]),
            # Visited locations: kitchen, backyard, and now driveway are visited
            self.visited(self.locationObjs["kitchen"]),
            self.visited(self.locationObjs["backyard"]),
            self.visited(self.locationObjs["driveway"]),
            # Door orientation: from driveway, the patioDoor is observed towards the north (leading to backyard)
            self.door_dir(self.doorObjs["patioDoor"], self.directionObjs["north"]),
            self.door_dir(self.doorObjs["plainDoor"], self.directionObjs["west"]),
            # The patio door is open as observed
            self.door_open(self.doorObjs["patioDoor"])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach an unvisited location, here unknownWest is unvisited
        return [self.at(self.locationObjs["unknownWest"])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
    (door driveway unknownWest west)
  )

  (:goal (at unknownWest))
)
### Environment feedback (if any)
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to allow movement when no door exists
    @action(Location, Location)
    def move_west(self, current, new):
        precond = [self.at(current), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only the north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]
--Small Loop--: 2 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
    (door driveway unknownWest west)
  )

  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to allow movement when no door exists
    @action(Location, Location)
    def move_west(self, current, new):
        precond = [self.at(current), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only the north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions :equality)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (not (visited ?to))
      (or
        (and (= ?dir south) (door ?from ?to south) (door_open ?from ?to south))
        (and (= ?dir west) (not (door ?from ?to west)))
      )
    )
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
  )

  (:goal (at unknownWest))
)
Actions from solver(df, pf): ['move west'] 
Raw plan text: (MOVE DRIVEWAY UNKNOWNWEST WEST)
 
Current action_queue: ['move west'] 
> move west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to allow movement when no door exists
    @action(Location, Location)
    def move_west(self, current, new):
        precond = [self.at(current), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only the north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions :equality)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (not (visited ?to))
      (or
        (and (= ?dir south) (door ?from ?to south) (door_open ?from ?to south))
        (and (= ?dir west) (not (door ?from ?to west)))
      )
    )
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
  )

  (:goal (at unknownWest))
)
### Environment feedback (if any)
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to require a door with west direction
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only a north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]
--Small Loop--: 3 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions :equality)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (not (visited ?to))
      (or
        (and (= ?dir south) (door ?from ?to south) (door_open ?from ?to south))
        (and (= ?dir west) (not (door ?from ?to west)))
      )
    )
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
  )

  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to require a door with west direction
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only a north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
  )

  (:goal (at unknownWest))
)
Actions from solver(df, pf): None 
Raw plan text:  
--Small Loop--: 1 
[IR→PDDL Prompt Retry] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway backyard south)
    (door_open driveway backyard south)
  )

  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to FALSE. No plan will solve it
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to require a door with west direction
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only a north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway unknownWest north)
    (door_open driveway unknownWest north)
  )

  (:goal (at unknownWest))
)
Actions from solver(df, pf): ['move north'] 
Raw plan text: (MOVE DRIVEWAY UNKNOWNWEST NORTH)
 
Current action_queue: ['move north'] 
> move north 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 3==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated move_west action to require a door with west direction
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['kitchen', 'backyard', 'driveway', 'unknownWest'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['patioDoor', 'plainDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['driveway']),
            self.visited(self.locationObjs['kitchen']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['driveway']),
            # Only a north door is observed; no door exists to the west as per the latest observation
            self.door_dir(self.doorObjs['patioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['patioDoor'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway unknownWest north)
    (door_open driveway unknownWest north)
  )

  (:goal (at unknownWest))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_north(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'north'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['backyard', 'kitchen', 'driveway', 'unknownWest', 'street'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['northPatioDoor', 'southDoor', 'westPatioDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['north', 'south', 'west'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['backyard']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['kitchen']),
            self.door_dir(self.doorObjs['northPatioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['northPatioDoor']),
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_dir(self.doorObjs['westPatioDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest - location
    south west north - direction
  )

  (:init
    (at driveway)
    (visited kitchen)
    (visited backyard)
    (visited driveway)
    (door driveway unknownWest north)
    (door_open driveway unknownWest north)
  )

  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_north(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'north'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['backyard', 'kitchen', 'driveway', 'unknownWest', 'street'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['northPatioDoor', 'southDoor', 'westPatioDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['north', 'south', 'west'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['backyard']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['kitchen']),
            self.door_dir(self.doorObjs['northPatioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['northPatioDoor']),
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_dir(self.doorObjs['westPatioDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest street - location
    north south west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    (visited kitchen)
    (door backyard kitchen north)
    (door_open backyard kitchen north)
    (door backyard driveway south)
    (door backyard unknownWest west)
  )
  (:goal (at unknownWest))
)
Actions from solver(df, pf): ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR BACKYARD UNKNOWNWEST WEST)
(MOVE BACKYARD UNKNOWNWEST WEST)
 
Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the patio door, revealing the living room.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the living room. In one part of the room you see a wastepaper basket that is closed. There is also a book case, that has nothing on it. You also see a TV stand, that has nothing on it. In another part of the room you see a arm chair, that has nothing on it. In one part of the room you see a side table, that has nothing on it. There is also a coffee table, that has nothing on it. You also see a end table, that has nothing on it. In another part of the room you see a sofa, that has nothing on it. 
To the South you see a closed wood door. Through an open patio door, to the East you see the backyard.  


====Step 4==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
You open the patio door, revealing the living room. 

Action: move west
You are in the living room. To the South you see a closed wood door. Through an open patio door, to the East you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')
    
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_north(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'north'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorationDomain.Location.create_objs(['backyard', 'kitchen', 'driveway', 'unknownWest', 'street'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['northPatioDoor', 'southDoor', 'westPatioDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['north', 'south', 'west'])

    @init
    def init(self):
        state = [
            self.at(self.locationObjs['backyard']),
            self.visited(self.locationObjs['backyard']),
            self.visited(self.locationObjs['kitchen']),
            self.door_dir(self.doorObjs['northPatioDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['northPatioDoor']),
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_dir(self.doorObjs['westPatioDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        return [self.at(self.locationObjs['unknownWest'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest street - location
    north south west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    (visited kitchen)
    (door backyard kitchen north)
    (door_open backyard kitchen north)
    (door backyard driveway south)
    (door backyard unknownWest west)
  )
  (:goal (at unknownWest))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define only the objects observed in current exploration
        self.locationObjs = ExplorationDomain.Location.create_objs(['living_room', 'backyard', 'unknownSouth'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['southDoor', 'westPatioDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent is currently in the living room and it has been visited
            self.at(self.locationObjs['living_room']),
            self.visited(self.locationObjs['living_room']),
            # Backyard was visited previously and is visible to the east
            self.visited(self.locationObjs['backyard']),
            # The west patio door has been opened to reveal the living room
            self.door_dir(self.doorObjs['westPatioDoor'], self.directionObjs['west']),
            self.door_open(self.doorObjs['westPatioDoor']),
            # A closed wood door to the south is observed in the living room
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to a not yet visited location, here the unknown room to the south
        return [self.at(self.locationObjs['unknownSouth'])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
You open the patio door, revealing the living room. 

Action: move west
You are in the living room. To the South you see a closed wood door. Through an open patio door, to the East you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen backyard driveway unknownWest street - location
    north south west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    (visited kitchen)
    (door backyard kitchen north)
    (door_open backyard kitchen north)
    (door backyard driveway south)
    (door backyard unknownWest west)
  )
  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define only the objects observed in current exploration
        self.locationObjs = ExplorationDomain.Location.create_objs(['living_room', 'backyard', 'unknownSouth'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['southDoor', 'westPatioDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent is currently in the living room and it has been visited
            self.at(self.locationObjs['living_room']),
            self.visited(self.locationObjs['living_room']),
            # Backyard was visited previously and is visible to the east
            self.visited(self.locationObjs['backyard']),
            # The west patio door has been opened to reveal the living room
            self.door_dir(self.doorObjs['westPatioDoor'], self.directionObjs['west']),
            self.door_open(self.doorObjs['westPatioDoor']),
            # A closed wood door to the south is observed in the living room
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to a not yet visited location, here the unknown room to the south
        return [self.at(self.locationObjs['unknownSouth'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room backyard unknownSouth - location
    south west - direction
  )
  (:init
    (at living_room)
    (visited living_room)
    (visited backyard)
    (door backyard living_room west)
    (door_open backyard living_room west)
    (door living_room unknownSouth south)
  )
  (:goal (at unknownSouth))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR LIVING_ROOM UNKNOWNSOUTH SOUTH)
(MOVE LIVING_ROOM UNKNOWNSOUTH SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the wood door, revealing the bathroom.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the bathroom. In one part of the room you see a dressing table, that has nothing on it. There is also a sink, that has nothing on it. You also see a wall hook, that has nothing on it. In another part of the room you see a bath mat. In one part of the room you see a toilet roll holder, that has nothing on it. There is also a towel rack, that has nothing on it. You also see a bath tub, that has nothing on it. In another part of the room you see a shower, that has nothing on it. In one part of the room you see a trash can that is closed. There is also a bathroom cabinet that is closed. You also see a toilet. 
Through an open wood door, to the North you see the living room. To the South you see a closed wood door. To the West you see a closed wood door.  


====Step 5==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the wood door, revealing the bathroom. 

Action: move south
You are in the bathroom. Through an open wood door, to the North you see the living room. To the South you see a closed wood door. To the West you see a closed wood door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define only the objects observed in current exploration
        self.locationObjs = ExplorationDomain.Location.create_objs(['living_room', 'backyard', 'unknownSouth'])
        self.doorObjs = ExplorationDomain.Door.create_objs(['southDoor', 'westPatioDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent is currently in the living room and it has been visited
            self.at(self.locationObjs['living_room']),
            self.visited(self.locationObjs['living_room']),
            # Backyard was visited previously and is visible to the east
            self.visited(self.locationObjs['backyard']),
            # The west patio door has been opened to reveal the living room
            self.door_dir(self.doorObjs['westPatioDoor'], self.directionObjs['west']),
            self.door_open(self.doorObjs['westPatioDoor']),
            # A closed wood door to the south is observed in the living room
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to a not yet visited location, here the unknown room to the south
        return [self.at(self.locationObjs['unknownSouth'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room backyard unknownSouth - location
    south west - direction
  )
  (:init
    (at living_room)
    (visited living_room)
    (visited backyard)
    (door backyard living_room west)
    (door_open backyard living_room west)
    (door living_room unknownSouth south)
  )
  (:goal (at unknownSouth))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: the previously visited living_room, the current bathroom, and two unvisited rooms beyond the bathroom doors
        self.locationObjs = ExplorationDomain.Location.create_objs(['living_room', 'bathroom', 'unknownSouth', 'unknownWest'])
        # Define doors: the door from living_room to bathroom, and the two new doors observed in the bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs(['southDoor', 'bathroom_southDoor', 'bathroom_westDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the bathroom
            self.at(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['bathroom']),
            # The living room was visited previously
            self.visited(self.locationObjs['living_room']),
            # The door connecting living_room and bathroom is open (or remains open after the move)
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            # In the bathroom, a closed wood door is observed to the south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            # In the bathroom, a closed wood door is observed to the west
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location, here we choose the room beyond the south door in the bathroom
        return [self.at(self.locationObjs['unknownSouth'])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the wood door, revealing the bathroom. 

Action: move south
You are in the bathroom. Through an open wood door, to the North you see the living room. To the South you see a closed wood door. To the West you see a closed wood door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room backyard unknownSouth - location
    south west - direction
  )
  (:init
    (at living_room)
    (visited living_room)
    (visited backyard)
    (door backyard living_room west)
    (door_open backyard living_room west)
    (door living_room unknownSouth south)
  )
  (:goal (at unknownSouth))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: the previously visited living_room, the current bathroom, and two unvisited rooms beyond the bathroom doors
        self.locationObjs = ExplorationDomain.Location.create_objs(['living_room', 'bathroom', 'unknownSouth', 'unknownWest'])
        # Define doors: the door from living_room to bathroom, and the two new doors observed in the bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs(['southDoor', 'bathroom_southDoor', 'bathroom_westDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the bathroom
            self.at(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['bathroom']),
            # The living room was visited previously
            self.visited(self.locationObjs['living_room']),
            # The door connecting living_room and bathroom is open (or remains open after the move)
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            # In the bathroom, a closed wood door is observed to the south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            # In the bathroom, a closed wood door is observed to the west
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location, here we choose the room beyond the south door in the bathroom
        return [self.at(self.locationObjs['unknownSouth'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom unknownSouth unknownWest - location
    south west - direction
  )
  (:init
    (at bathroom)
    (visited bathroom)
    (visited living_room)
    (door living_room bathroom south)
    (door_open living_room bathroom south)
    (door bathroom unknownSouth south)
    (door bathroom unknownWest west)
  )
  (:goal (at unknownSouth))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR BATHROOM UNKNOWNSOUTH SOUTH)
(MOVE BATHROOM UNKNOWNSOUTH SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the wood door, revealing the laundry room.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the laundry room. In one part of the room you see a bench, that has nothing on it. There is also a work table, that has nothing on it. You also see a clothes drier that is closed. In another part of the room you see a laundry basket, that has nothing on it. In one part of the room you see a washing machine that is closed. 
Through an open wood door, to the North you see the bathroom.  


====Step 6==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the wood door, revealing the laundry room. 

Action: move south
You are in the laundry room. Through an open wood door, to the North you see the bathroom. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: the previously visited living_room, the current bathroom, and two unvisited rooms beyond the bathroom doors
        self.locationObjs = ExplorationDomain.Location.create_objs(['living_room', 'bathroom', 'unknownSouth', 'unknownWest'])
        # Define doors: the door from living_room to bathroom, and the two new doors observed in the bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs(['southDoor', 'bathroom_southDoor', 'bathroom_westDoor'])
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the bathroom
            self.at(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['bathroom']),
            # The living room was visited previously
            self.visited(self.locationObjs['living_room']),
            # The door connecting living_room and bathroom is open (or remains open after the move)
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            # In the bathroom, a closed wood door is observed to the south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            # In the bathroom, a closed wood door is observed to the west
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location, here we choose the room beyond the south door in the bathroom
        return [self.at(self.locationObjs['unknownSouth'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom unknownSouth unknownWest - location
    south west - direction
  )
  (:init
    (at bathroom)
    (visited bathroom)
    (visited living_room)
    (door living_room bathroom south)
    (door_open living_room bathroom south)
    (door bathroom unknownSouth south)
    (door bathroom unknownWest west)
  )
  (:goal (at unknownSouth))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: previously visited living_room and bathroom, the newly discovered laundry_room, and an unvisited room to the west
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'unknownWest'
        ])
        
        # Define doors:
        #  - 'southDoor' connects living_room and bathroom
        #  - 'bathroom_southDoor' is the door (with south orientation from bathroom) that was opened to reveal the laundry_room
        #  - 'bathroom_westDoor' is the door from bathroom to an unvisited room (unknownWest), still closed
        #  - 'laundry_northDoor' is observed from the laundry room as an open wood door to the north leading back to bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'laundry_northDoor'
        ])
        
        # Define directions: south and west as before, and north as newly observed
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the laundry room (newly discovered via the south door from bathroom)
            self.at(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['laundry_room']),
            
            # Previously visited rooms
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from living_room to bathroom is set with direction south and is open
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: now open after executing open_door_south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to unknownWest remains in place (closed)
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            
            # Observed from the laundry room: an open wood door to the north leading to bathroom
            self.door_dir(self.doorObjs['laundry_northDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['laundry_northDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the room to the west (unknownWest) remains unvisited
        return [self.at(self.locationObjs['unknownWest'])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the wood door, revealing the laundry room. 

Action: move south
You are in the laundry room. Through an open wood door, to the North you see the bathroom. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom unknownSouth unknownWest - location
    south west - direction
  )
  (:init
    (at bathroom)
    (visited bathroom)
    (visited living_room)
    (door living_room bathroom south)
    (door_open living_room bathroom south)
    (door bathroom unknownSouth south)
    (door bathroom unknownWest west)
  )
  (:goal (at unknownSouth))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: previously visited living_room and bathroom, the newly discovered laundry_room, and an unvisited room to the west
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'unknownWest'
        ])
        
        # Define doors:
        #  - 'southDoor' connects living_room and bathroom
        #  - 'bathroom_southDoor' is the door (with south orientation from bathroom) that was opened to reveal the laundry_room
        #  - 'bathroom_westDoor' is the door from bathroom to an unvisited room (unknownWest), still closed
        #  - 'laundry_northDoor' is observed from the laundry room as an open wood door to the north leading back to bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'laundry_northDoor'
        ])
        
        # Define directions: south and west as before, and north as newly observed
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the laundry room (newly discovered via the south door from bathroom)
            self.at(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['laundry_room']),
            
            # Previously visited rooms
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from living_room to bathroom is set with direction south and is open
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: now open after executing open_door_south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to unknownWest remains in place (closed)
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            
            # Observed from the laundry room: an open wood door to the north leading to bathroom
            self.door_dir(self.doorObjs['laundry_northDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['laundry_northDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the room to the west (unknownWest) remains unvisited
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room unknownWest - location
    south west north - direction
  )
  (:init
    (at laundry_room)
    (visited laundry_room)
    (visited bathroom)
    (visited living_room)

    (door living_room bathroom south)
    (door_open living_room bathroom south)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom unknownWest west)

    (door laundry_room bathroom north)
    (door_open laundry_room bathroom north)
  )
  (:goal (at unknownWest))
)
Actions from solver(df, pf): None 
Raw plan text:  
--Small Loop--: 1 
[IR→PDDL Prompt Retry] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the wood door, revealing the laundry room. 

Action: move south
You are in the laundry room. Through an open wood door, to the North you see the bathroom. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room unknownWest - location
    south west north - direction
  )
  (:init
    (at laundry_room)
    (visited laundry_room)
    (visited bathroom)
    (visited living_room)

    (door living_room bathroom south)
    (door_open living_room bathroom south)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom unknownWest west)

    (door laundry_room bathroom north)
    (door_open laundry_room bathroom north)
  )
  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to FALSE. No plan will solve it
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: previously visited living_room and bathroom, the newly discovered laundry_room, and an unvisited room to the west
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'unknownWest'
        ])
        
        # Define doors:
        #  - 'southDoor' connects living_room and bathroom
        #  - 'bathroom_southDoor' is the door (with south orientation from bathroom) that was opened to reveal the laundry_room
        #  - 'bathroom_westDoor' is the door from bathroom to an unvisited room (unknownWest), still closed
        #  - 'laundry_northDoor' is observed from the laundry room as an open wood door to the north leading back to bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'laundry_northDoor'
        ])
        
        # Define directions: south and west as before, and north as newly observed
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the laundry room (newly discovered via the south door from bathroom)
            self.at(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['laundry_room']),
            
            # Previously visited rooms
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from living_room to bathroom is set with direction south and is open
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: now open after executing open_door_south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to unknownWest remains in place (closed)
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            
            # Observed from the laundry room: an open wood door to the north leading to bathroom
            self.door_dir(self.doorObjs['laundry_northDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['laundry_northDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the room to the west (unknownWest) remains unvisited
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room unknownWest - location
    south west north - direction
  )
  (:init
    (at laundry_room)
    (visited laundry_room)
    (visited living_room)

    (door living_room bathroom south)
    (door_open living_room bathroom south)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom unknownWest west)

    (door laundry_room bathroom north)
    (door_open laundry_room bathroom north)
  )
  (:goal (at unknownWest))
)
Actions from solver(df, pf): ['move north', 'open door to west', 'move west'] 
Raw plan text: (MOVE LAUNDRY_ROOM BATHROOM NORTH)
(OPEN-DOOR BATHROOM UNKNOWNWEST WEST)
(MOVE BATHROOM UNKNOWNWEST WEST)
 
Current action_queue: ['move north', 'open door to west', 'move west'] 
> move north 
 You are in the bathroom. In one part of the room you see a dressing table, that has nothing on it. There is also a sink, that has nothing on it. You also see a wall hook, that has nothing on it. In another part of the room you see a bath mat. In one part of the room you see a toilet roll holder, that has nothing on it. There is also a towel rack, that has nothing on it. You also see a bath tub, that has nothing on it. In another part of the room you see a shower, that has nothing on it. In one part of the room you see a trash can that is closed. There is also a bathroom cabinet that is closed. You also see a toilet. 
Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. To the West you see a closed wood door.  
Small Loop, action_queue: ['open door to west', 'move west'] 
Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the wood door, revealing the corridor.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the corridor. In one part of the room you see a key holder, that has nothing on it. There is also a shoe cabinet that is closed. You also see a umbrella stand, that has nothing on it. In another part of the room you see a hat rack, that has nothing on it. In one part of the room you see a coat hanger, that has nothing on it. 
Through an open wood door, to the East you see the bathroom. To the West you see a closed wood door.  


====Step 7==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. To the West you see a closed wood door. 

Action: open door to west
You open the wood door, revealing the corridor. 

Action: move west
You are in the corridor. Through an open wood door, to the East you see the bathroom. To the West you see a closed wood door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(ExplorationDomain.Location, ExplorationDomain.Door, ExplorationDomain.Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: previously visited living_room and bathroom, the newly discovered laundry_room, and an unvisited room to the west
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'unknownWest'
        ])
        
        # Define doors:
        #  - 'southDoor' connects living_room and bathroom
        #  - 'bathroom_southDoor' is the door (with south orientation from bathroom) that was opened to reveal the laundry_room
        #  - 'bathroom_westDoor' is the door from bathroom to an unvisited room (unknownWest), still closed
        #  - 'laundry_northDoor' is observed from the laundry room as an open wood door to the north leading back to bathroom
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'laundry_northDoor'
        ])
        
        # Define directions: south and west as before, and north as newly observed
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # The agent has moved and is now in the laundry room (newly discovered via the south door from bathroom)
            self.at(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['laundry_room']),
            
            # Previously visited rooms
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from living_room to bathroom is set with direction south and is open
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: now open after executing open_door_south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to unknownWest remains in place (closed)
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            
            # Observed from the laundry room: an open wood door to the north leading to bathroom
            self.door_dir(self.doorObjs['laundry_northDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['laundry_northDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the room to the west (unknownWest) remains unvisited
        return [self.at(self.locationObjs['unknownWest'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room unknownWest - location
    south west north - direction
  )
  (:init
    (at laundry_room)
    (visited laundry_room)
    (visited living_room)

    (door living_room bathroom south)
    (door_open living_room bathroom south)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom unknownWest west)

    (door laundry_room bathroom north)
    (door_open laundry_room bathroom north)
  )
  (:goal (at unknownWest))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: living_room, bathroom, laundry_room, corridor (discovered after opening the west door), and an unvisited room beyond the corridor
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'corridor',
            'unknownWest'
        ])
        
        # Define doors:
        # - 'southDoor': from bathroom to living_room (observed to the north from bathroom)
        # - 'bathroom_southDoor': from bathroom to laundry_room (to the south)
        # - 'bathroom_westDoor': from bathroom to corridor (was closed then opened)
        # - 'corridor_westDoor': from corridor to an unvisited room (still closed)
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'corridor_westDoor'
        ])
        
        # Define directions: south, west, and north
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # Agent is now in the corridor after moving west
            self.at(self.locationObjs['corridor']),
            self.visited(self.locationObjs['corridor']),
            
            # Previously visited locations
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from bathroom to living_room: observed from bathroom as an open door to the north
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: open and to the south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to corridor: now open to the west after opening the door
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            self.door_open(self.doorObjs['bathroom_westDoor']),
            
            # Door from corridor to the unvisited room remains closed
            self.door_dir(self.doorObjs['corridor_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the unvisited room beyond the corridor (unknownWest) remains
        return [self.at(self.locationObjs['unknownWest'])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. To the West you see a closed wood door. 

Action: open door to west
You open the wood door, revealing the corridor. 

Action: move west
You are in the corridor. Through an open wood door, to the East you see the bathroom. To the West you see a closed wood door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room unknownWest - location
    south west north - direction
  )
  (:init
    (at laundry_room)
    (visited laundry_room)
    (visited living_room)

    (door living_room bathroom south)
    (door_open living_room bathroom south)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom unknownWest west)

    (door laundry_room bathroom north)
    (door_open laundry_room bathroom north)
  )
  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: living_room, bathroom, laundry_room, corridor (discovered after opening the west door), and an unvisited room beyond the corridor
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'corridor',
            'unknownWest'
        ])
        
        # Define doors:
        # - 'southDoor': from bathroom to living_room (observed to the north from bathroom)
        # - 'bathroom_southDoor': from bathroom to laundry_room (to the south)
        # - 'bathroom_westDoor': from bathroom to corridor (was closed then opened)
        # - 'corridor_westDoor': from corridor to an unvisited room (still closed)
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'corridor_westDoor'
        ])
        
        # Define directions: south, west, and north
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # Agent is now in the corridor after moving west
            self.at(self.locationObjs['corridor']),
            self.visited(self.locationObjs['corridor']),
            
            # Previously visited locations
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from bathroom to living_room: observed from bathroom as an open door to the north
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: open and to the south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to corridor: now open to the west after opening the door
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            self.door_open(self.doorObjs['bathroom_westDoor']),
            
            # Door from corridor to the unvisited room remains closed
            self.door_dir(self.doorObjs['corridor_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the unvisited room beyond the corridor (unknownWest) remains
        return [self.at(self.locationObjs['unknownWest'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room corridor unknownWest - location
    south west north - direction
  )
  (:init
    (at corridor)
    (visited corridor)
    (visited bathroom)
    (visited laundry_room)
    (visited living_room)

    (door bathroom living_room north)
    (door_open bathroom living_room north)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom corridor west)
    (door_open bathroom corridor west)

    (door corridor unknownWest west)
  )
  (:goal (at unknownWest))
)
Actions from solver(df, pf): ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR CORRIDOR UNKNOWNWEST WEST)
(MOVE CORRIDOR UNKNOWNWEST WEST)
 
Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the wood door, revealing the bedroom.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the bedroom. In one part of the room you see a dressing table, that has nothing on it. There is also a desk chair, that has nothing on it. You also see a desk, that has nothing on it. In another part of the room you see a chest of drawers that is closed. In one part of the room you see a wardrobe that is closed. There is also a night stand, that has nothing on it. You also see a bed, that has nothing on it. 
Through an open wood door, to the East you see the corridor.  


====Step 8==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
You open the wood door, revealing the bedroom. 

Action: move west
You are in the bedroom. Through an open wood door, to the East you see the corridor. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: living_room, bathroom, laundry_room, corridor (discovered after opening the west door), and an unvisited room beyond the corridor
        self.locationObjs = ExplorationDomain.Location.create_objs([
            'living_room',
            'bathroom',
            'laundry_room',
            'corridor',
            'unknownWest'
        ])
        
        # Define doors:
        # - 'southDoor': from bathroom to living_room (observed to the north from bathroom)
        # - 'bathroom_southDoor': from bathroom to laundry_room (to the south)
        # - 'bathroom_westDoor': from bathroom to corridor (was closed then opened)
        # - 'corridor_westDoor': from corridor to an unvisited room (still closed)
        self.doorObjs = ExplorationDomain.Door.create_objs([
            'southDoor',
            'bathroom_southDoor',
            'bathroom_westDoor',
            'corridor_westDoor'
        ])
        
        # Define directions: south, west, and north
        self.directionObjs = ExplorationDomain.Direction.create_objs([
            'south',
            'west',
            'north'
        ])

    @init
    def init(self):
        state = [
            # Agent is now in the corridor after moving west
            self.at(self.locationObjs['corridor']),
            self.visited(self.locationObjs['corridor']),
            
            # Previously visited locations
            self.visited(self.locationObjs['bathroom']),
            self.visited(self.locationObjs['laundry_room']),
            self.visited(self.locationObjs['living_room']),
            
            # Door from bathroom to living_room: observed from bathroom as an open door to the north
            self.door_dir(self.doorObjs['southDoor'], self.directionObjs['north']),
            self.door_open(self.doorObjs['southDoor']),
            
            # Door from bathroom to laundry_room: open and to the south
            self.door_dir(self.doorObjs['bathroom_southDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bathroom_southDoor']),
            
            # Door from bathroom to corridor: now open to the west after opening the door
            self.door_dir(self.doorObjs['bathroom_westDoor'], self.directionObjs['west']),
            self.door_open(self.doorObjs['bathroom_westDoor']),
            
            # Door from corridor to the unvisited room remains closed
            self.door_dir(self.doorObjs['corridor_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to explore an unvisited location; here, the unvisited room beyond the corridor (unknownWest) remains
        return [self.at(self.locationObjs['unknownWest'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room corridor unknownWest - location
    south west north - direction
  )
  (:init
    (at corridor)
    (visited corridor)
    (visited bathroom)
    (visited laundry_room)
    (visited living_room)

    (door bathroom living_room north)
    (door_open bathroom living_room north)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom corridor west)
    (door_open bathroom corridor west)

    (door corridor unknownWest west)
  )
  (:goal (at unknownWest))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the observed locations: 'bedroom' (current location) and 'corridor' (seen through the door from bedroom)
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define the door objects based on observations:
        # 'woodDoor_west' is the door that was opened to reveal the bedroom,
        # and 'bedroom_eastDoor' is observed as an open door to the east showing the corridor.
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_eastDoor'])
        
        # Define directions based on valid actions and observations
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'east'])

    @init
    def init(self):
        state = [
            # Agent is now in the bedroom after moving west
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The wood door to the west has been opened to access the bedroom
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            self.door_open(self.doorObjs['woodDoor_west']),
            
            # From the bedroom an open door to the east shows the corridor
            self.door_dir(self.doorObjs['bedroom_eastDoor'], self.directionObjs['east']),
            self.door_open(self.doorObjs['bedroom_eastDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach an unvisited location. Here, the corridor (observed to the east) has not been visited.
        return [self.at(self.locationObjs['corridor'])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
You open the wood door, revealing the bedroom. 

Action: move west
You are in the bedroom. Through an open wood door, to the East you see the corridor. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    living_room bathroom laundry_room corridor unknownWest - location
    south west north - direction
  )
  (:init
    (at corridor)
    (visited corridor)
    (visited bathroom)
    (visited laundry_room)
    (visited living_room)

    (door bathroom living_room north)
    (door_open bathroom living_room north)

    (door bathroom laundry_room south)
    (door_open bathroom laundry_room south)

    (door bathroom corridor west)
    (door_open bathroom corridor west)

    (door corridor unknownWest west)
  )
  (:goal (at unknownWest))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the observed locations: 'bedroom' (current location) and 'corridor' (seen through the door from bedroom)
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define the door objects based on observations:
        # 'woodDoor_west' is the door that was opened to reveal the bedroom,
        # and 'bedroom_eastDoor' is observed as an open door to the east showing the corridor.
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_eastDoor'])
        
        # Define directions based on valid actions and observations
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'east'])

    @init
    def init(self):
        state = [
            # Agent is now in the bedroom after moving west
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The wood door to the west has been opened to access the bedroom
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            self.door_open(self.doorObjs['woodDoor_west']),
            
            # From the bedroom an open door to the east shows the corridor
            self.door_dir(self.doorObjs['bedroom_eastDoor'], self.directionObjs['east']),
            self.door_open(self.doorObjs['bedroom_eastDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach an unvisited location. Here, the corridor (observed to the east) has not been visited.
        return [self.at(self.locationObjs['corridor'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west east - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door_open bedroom corridor west)
  )
  (:goal (at corridor))
)
Actions from solver(df, pf): ['move west'] 
Raw plan text: (MOVE BEDROOM CORRIDOR WEST)
 
Current action_queue: ['move west'] 
> move west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    @predicate(Door)
    def door_open(self, door):
        pass

    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the observed locations: 'bedroom' (current location) and 'corridor' (seen through the door from bedroom)
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define the door objects based on observations:
        # 'woodDoor_west' is the door that was opened to reveal the bedroom,
        # and 'bedroom_eastDoor' is observed as an open door to the east showing the corridor.
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_eastDoor'])
        
        # Define directions based on valid actions and observations
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'east'])

    @init
    def init(self):
        state = [
            # Agent is now in the bedroom after moving west
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The wood door to the west has been opened to access the bedroom
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            self.door_open(self.doorObjs['woodDoor_west']),
            
            # From the bedroom an open door to the east shows the corridor
            self.door_dir(self.doorObjs['bedroom_eastDoor'], self.directionObjs['east']),
            self.door_open(self.doorObjs['bedroom_eastDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach an unvisited location. Here, the corridor (observed to the east) has not been visited.
        return [self.at(self.locationObjs['corridor'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west east - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door_open bedroom corridor west)
  )
  (:goal (at corridor))
)
### Environment feedback (if any)
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicates to indicate the agent's current location and visit history
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate to indicate whether a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate to state the direction associated with a door
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the observed locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects based on observations:
        # 'woodDoor_west' is observed as a door to the west but is currently closed
        # 'bedroom_eastDoor' (renamed for consistency) is now used to represent the door to the south leading to the corridor
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_eastDoor'])
        
        # Define directions based on valid actions and observations
        # Listed directions include south, west, and east (east remains for potential future use)
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'east'])

    @init
    def init(self):
        state = [
            # Agent is currently in the bedroom
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The west door exists but is closed, so move_west cannot be performed
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            
            # The door to the south is open, allowing movement to the unvisited corridor via move_south
            self.door_dir(self.doorObjs['bedroom_eastDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bedroom_eastDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach the unvisited corridor
        return [self.at(self.locationObjs['corridor'])]
--Small Loop--: 2 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west east - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door_open bedroom corridor west)
  )
  (:goal (at corridor))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicates to indicate the agent's current location and visit history
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate to indicate whether a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate to state the direction associated with a door
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the observed locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects based on observations:
        # 'woodDoor_west' is observed as a door to the west but is currently closed
        # 'bedroom_eastDoor' (renamed for consistency) is now used to represent the door to the south leading to the corridor
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_eastDoor'])
        
        # Define directions based on valid actions and observations
        # Listed directions include south, west, and east (east remains for potential future use)
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'east'])

    @init
    def init(self):
        state = [
            # Agent is currently in the bedroom
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The west door exists but is closed, so move_west cannot be performed
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            
            # The door to the south is open, allowing movement to the unvisited corridor via move_south
            self.door_dir(self.doorObjs['bedroom_eastDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bedroom_eastDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach the unvisited corridor
        return [self.at(self.locationObjs['corridor'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west east - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door bedroom corridor south)
    (door_open bedroom corridor south)
  )
  (:goal (at corridor))
)
Actions from solver(df, pf): ['move south'] 
Raw plan text: (MOVE BEDROOM CORRIDOR SOUTH)
 
Current action_queue: ['move south'] 
> move south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicates to indicate the agent's current location and visit history
    @predicate(Location)
    def at(self, loc):
        pass

    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate to indicate whether a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate to state the direction associated with a door
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the observed locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects based on observations:
        # 'woodDoor_west' is observed as a door to the west but is currently closed
        # 'bedroom_eastDoor' (renamed for consistency) is now used to represent the door to the south leading to the corridor
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_eastDoor'])
        
        # Define directions based on valid actions and observations
        # Listed directions include south, west, and east (east remains for potential future use)
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'east'])

    @init
    def init(self):
        state = [
            # Agent is currently in the bedroom
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The west door exists but is closed, so move_west cannot be performed
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            
            # The door to the south is open, allowing movement to the unvisited corridor via move_south
            self.door_dir(self.doorObjs['bedroom_eastDoor'], self.directionObjs['south']),
            self.door_open(self.doorObjs['bedroom_eastDoor'])
        ]
        return state

    @goal
    def goal(self):
        # The exploration goal is to reach the unvisited corridor
        return [self.at(self.locationObjs['corridor'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west east - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door bedroom corridor south)
    (door_open bedroom corridor south)
  )
  (:goal (at corridor))
)
### Environment feedback (if any)
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define observed locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects based on observations:
        # 'woodDoor_west' is observed as the door to the west
        # 'bedroom_southDoor' is observed as the door to the south
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_southDoor'])
        
        # Define directions based on valid actions and observations
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent is currently in the bedroom and has visited it
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The west door is associated with the west direction (currently closed)
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            
            # The door to the south is associated with the south direction and is closed, preventing move south
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to reach the unvisited corridor
        return [self.at(self.locationObjs['corridor'])]
--Small Loop--: 3 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west east - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door bedroom corridor south)
    (door_open bedroom corridor south)
  )
  (:goal (at corridor))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define observed locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects based on observations:
        # 'woodDoor_west' is observed as the door to the west
        # 'bedroom_southDoor' is observed as the door to the south
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_southDoor'])
        
        # Define directions based on valid actions and observations
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent is currently in the bedroom and has visited it
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The west door is associated with the west direction (currently closed)
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            
            # The door to the south is associated with the south direction and is closed, preventing move south
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to reach the unvisited corridor
        return [self.at(self.locationObjs['corridor'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door bedroom corridor south)
  )
  (:goal (at corridor))
)
Actions from solver(df, pf): ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR BEDROOM CORRIDOR WEST)
(MOVE BEDROOM CORRIDOR WEST)
 
Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 3---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define observed locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects based on observations:
        # 'woodDoor_west' is observed as the door to the west
        # 'bedroom_southDoor' is observed as the door to the south
        self.doorObjs = ExplorationDomain.Door.create_objs(['woodDoor_west', 'bedroom_southDoor'])
        
        # Define directions based on valid actions and observations
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent is currently in the bedroom and has visited it
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # The west door is associated with the west direction (currently closed)
            self.door_dir(self.doorObjs['woodDoor_west'], self.directionObjs['west']),
            
            # The door to the south is associated with the south direction and is closed, preventing move south
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to reach the unvisited corridor
        return [self.at(self.locationObjs['corridor'])]

### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door bedroom corridor south)
  )
  (:goal (at corridor))
)
### Environment feedback (if any)
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location (requires a door)
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location (no door required as west door is absent)
    @action(Location, Location)
    def move_west(self, current, new):
        precond = [self.at(current), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # In this observation, the door to the west is absent so only the south door is created
        self.doorObjs = ExplorationDomain.Door.create_objs(['bedroom_southDoor'])
        
        # Define directions based on the valid actions
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent starts in the bedroom and it has been visited
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # Only the south door is present and associated with the south direction
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to the unvisited corridor. Since there is no door to the west, the agent can move directly west.
        return [self.at(self.locationObjs['corridor'])]

--Small Loop--: 4 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (door ?from ?to ?dir) (door_open ?from ?to ?dir) (not (visited ?to)))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor west)
    (door bedroom corridor south)
  )
  (:goal (at corridor))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location (requires a door)
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location (no door required as west door is absent)
    @action(Location, Location)
    def move_west(self, current, new):
        precond = [self.at(current), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect


### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # In this observation, the door to the west is absent so only the south door is created
        self.doorObjs = ExplorationDomain.Door.create_objs(['bedroom_southDoor'])
        
        # Define directions based on the valid actions
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent starts in the bedroom and it has been visited
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # Only the south door is present and associated with the south direction
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to the unvisited corridor. Since there is no door to the west, the agent can move directly west.
        return [self.at(self.locationObjs['corridor'])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (visited ?to))
                       (or (and (door ?from ?to ?dir) (door_open ?from ?to ?dir))
                           (not (door ?from ?to ?dir))))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor south)
  )
  (:goal (at corridor))
)
Actions from solver(df, pf): ['move west'] 
Raw plan text: (MOVE BEDROOM CORRIDOR WEST)
 
Current action_queue: ['move west'] 
> move west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 4---- 
successful_actions: ['open door to south', 'move south', 'move south', 'move north', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location (requires a door)
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Action for moving west from the current location (no door required as west door is absent)
    @action(Location, Location)
    def move_west(self, current, new):
        precond = [self.at(current), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect


[py_problem]
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define locations: 'bedroom' is the current location and 'corridor' is an unvisited location
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # In this observation, the door to the west is absent so only the south door is created
        self.doorObjs = ExplorationDomain.Door.create_objs(['bedroom_southDoor'])
        
        # Define directions based on the valid actions
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent starts in the bedroom and it has been visited
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # Only the south door is present and associated with the south direction
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to move to the unvisited corridor. Since there is no door to the west, the agent can move directly west.
        return [self.at(self.locationObjs['corridor'])]


### Previous PDDL (edit minimally)
[df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (visited ?to))
                       (or (and (door ?from ?to ?dir) (door_open ?from ?to ?dir))
                           (not (door ?from ?to ?dir))))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor south)
  )
  (:goal (at corridor))
)
### Environment feedback (if any)
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location (requires an open south door)
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated action for moving west from the current location (requires an open west door)
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the locations: the agent starts in 'bedroom' and 'corridor' is the unvisited target
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects for both south and west directions from the bedroom
        self.doorObjs = ExplorationDomain.Door.create_objs(['bedroom_southDoor', 'bedroom_westDoor'])
        
        # Define directions as specified by the valid actions
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent starts at the bedroom and it is marked as visited
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # Associate the south door with the 'south' direction
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south']),
            
            # Associate the west door with the 'west' direction (door remains closed initially)
            self.door_dir(self.doorObjs['bedroom_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to reach the unvisited location 'corridor'
        return [self.at(self.locationObjs['corridor'])]
--Small Loop--: 5 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (visited ?to))
                       (or (and (door ?from ?to ?dir) (door_open ?from ?to ?dir))
                           (not (door ?from ?to ?dir))))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor south)
  )
  (:goal (at corridor))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move west. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    # Define types for locations, doors, and directions
    Location = create_type('Location')
    Door = create_type('Door')
    Direction = create_type('Direction')

    # Predicate indicating the agent's current location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate indicating whether a location has been visited
    @predicate(Location)
    def visited(self, loc):
        pass

    # Predicate indicating if a door is open
    @predicate(Door)
    def door_open(self, door):
        pass

    # Predicate associating a door with its direction
    @predicate(Door, Direction)
    def door_dir(self, door, dir_val):
        pass

    # Action to open a door to the south
    @action(Door)
    def open_door_south(self, door):
        precond = [self.door_dir(door, 'south'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to open a door to the west
    @action(Door)
    def open_door_west(self, door):
        precond = [self.door_dir(door, 'west'), ~self.door_open(door)]
        effect = [self.door_open(door)]
        return precond, effect

    # Action to close a door to the south
    @action(Door)
    def close_door_south(self, door):
        precond = [self.door_dir(door, 'south'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action to close a door to the west
    @action(Door)
    def close_door_west(self, door):
        precond = [self.door_dir(door, 'west'), self.door_open(door)]
        effect = [~self.door_open(door)]
        return precond, effect

    # Action for moving south from the current location (requires an open south door)
    @action(Location, Door, Location)
    def move_south(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'south'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

    # Updated action for moving west from the current location (requires an open west door)
    @action(Location, Door, Location)
    def move_west(self, current, door, new):
        precond = [self.at(current), self.door_dir(door, 'west'), self.door_open(door), ~self.visited(new)]
        effect = [~self.at(current), self.at(new), self.visited(new)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        # Define the locations: the agent starts in 'bedroom' and 'corridor' is the unvisited target
        self.locationObjs = ExplorationDomain.Location.create_objs(['bedroom', 'corridor'])
        
        # Define door objects for both south and west directions from the bedroom
        self.doorObjs = ExplorationDomain.Door.create_objs(['bedroom_southDoor', 'bedroom_westDoor'])
        
        # Define directions as specified by the valid actions
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'])

    @init
    def init(self):
        state = [
            # Agent starts at the bedroom and it is marked as visited
            self.at(self.locationObjs['bedroom']),
            self.visited(self.locationObjs['bedroom']),
            
            # Associate the south door with the 'south' direction
            self.door_dir(self.doorObjs['bedroom_southDoor'], self.directionObjs['south']),
            
            # Associate the west door with the 'west' direction (door remains closed initially)
            self.door_dir(self.doorObjs['bedroom_westDoor'], self.directionObjs['west'])
        ]
        return state

    @goal
    def goal(self):
        # The goal is to reach the unvisited location 'corridor'
        return [self.at(self.locationObjs['corridor'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing :negative-preconditions :disjunctive-preconditions)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (visited ?l - location)
    (door ?loc1 - location ?loc2 - location ?dir - direction)
    (door_open ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (door ?loc1 ?loc2 ?dir) (not (door_open ?loc1 ?loc2 ?dir)))
    :effect (door_open ?loc1 ?loc2 ?dir)
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (not (visited ?to))
                       (or (and (door ?from ?to ?dir) (door_open ?from ?to ?dir))
                           (not (door ?from ?to ?dir))))
    :effect (and (not (at ?from)) (at ?to) (visited ?to))
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    bedroom corridor - location
    south west - direction
  )
  (:init
    (at bedroom)
    (visited bedroom)
    (door bedroom corridor south)
    (door bedroom corridor west)
  )
  (:goal (at corridor))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR BEDROOM CORRIDOR SOUTH)
(MOVE BEDROOM CORRIDOR SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 
