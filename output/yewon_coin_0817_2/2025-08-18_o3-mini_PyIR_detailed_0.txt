Observations: You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
To the South you see a closed patio door. To the West you see a closed plain door.  
Gold path: ['look around', 'open door to south', 'open door to west', 'move south', 'open door to west', 'move north', 'move west', 'move east', 'move south', 'move west', 'open door to south', 'move east', 'move south', 'move north', 'move north', 'move west', 'move east', 'move west', 'move east', 'move west', 'move east', 'move west', 'move east', 'move south', 'move north', 'move south', 'move east', 'open door to north', 'move north', 'take coin'] 
Valid Actions: ['look around', 'close door to west', 'move west', 'open door to south', 'open door to west', 'inventory', 'move south', 'close door to south'] 
taskDescription: Your task is to search the environment and find the coin.  Once you find the coin, take it. 
brief_obs: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 
 


====Step 0==== 

----Larger Loop No. 0---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        """Agent is at location loc"""
        pass

    # Predicate: door is closed
    @predicate(Door)
    def door_closed(self, d):
        """Door d is closed"""
        pass

    # Predicate: door d is the south door
    @predicate(Door)
    def south_door(self, d):
        """Door d is the door to the south"""
        pass

    # Predicate: door d is the west door
    @predicate(Door)
    def west_door(self, d):
        """Door d is the door to the west"""
        pass

    # Predicate: door d connects location loc_from to loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        """Door d connects loc_from to loc_to"""
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door from a source location to a destination
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door from a source location to a destination
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Create objects for locations: the observed kitchen, and the rooms behind the doors
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "patio", "room_west"])
        # Create objects for doors: one to the south (patio door) and one to the west (plain door)
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door"])

    @init
    def init(self):
        init_state = [
            # Agent is initially in the kitchen
            self.at(self.locationObjs["kitchen"]),
            
            # Both doors are observed to be closed
            self.door_closed(self.doorObjs["south_door"]),
            self.door_closed(self.doorObjs["west_door"]),
            
            # Indicate the direction of each door
            self.south_door(self.doorObjs["south_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity: the south door connects the kitchen to the patio,
            # and the west door connects the kitchen to an unvisited room (room_west)
            self.connects(self.locationObjs["kitchen"], self.doorObjs["south_door"], self.locationObjs["patio"]),
            self.connects(self.locationObjs["kitchen"], self.doorObjs["west_door"], self.locationObjs["room_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to be in a location other than the kitchen; here we choose the patio
        return [self.at(self.locationObjs["patio"])]

--Small Loop--: 0 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
N/A

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        """Agent is at location loc"""
        pass

    # Predicate: door is closed
    @predicate(Door)
    def door_closed(self, d):
        """Door d is closed"""
        pass

    # Predicate: door d is the south door
    @predicate(Door)
    def south_door(self, d):
        """Door d is the door to the south"""
        pass

    # Predicate: door d is the west door
    @predicate(Door)
    def west_door(self, d):
        """Door d is the door to the west"""
        pass

    # Predicate: door d connects location loc_from to loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        """Door d connects loc_from to loc_to"""
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door from a source location to a destination
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door from a source location to a destination
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect


### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Create objects for locations: the observed kitchen, and the rooms behind the doors
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "patio", "room_west"])
        # Create objects for doors: one to the south (patio door) and one to the west (plain door)
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door"])

    @init
    def init(self):
        init_state = [
            # Agent is initially in the kitchen
            self.at(self.locationObjs["kitchen"]),
            
            # Both doors are observed to be closed
            self.door_closed(self.doorObjs["south_door"]),
            self.door_closed(self.doorObjs["west_door"]),
            
            # Indicate the direction of each door
            self.south_door(self.doorObjs["south_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity: the south door connects the kitchen to the patio,
            # and the west door connects the kitchen to an unvisited room (room_west)
            self.connects(self.locationObjs["kitchen"], self.doorObjs["south_door"], self.locationObjs["patio"]),
            self.connects(self.locationObjs["kitchen"], self.doorObjs["west_door"], self.locationObjs["room_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to be in a location other than the kitchen; here we choose the patio
        return [self.at(self.locationObjs["patio"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen patio room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (closed kitchen patio south)
    (closed kitchen room_west west)
    (connected kitchen patio south)
    (connected kitchen room_west west)
  )
  (:goal (at patio))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR KITCHEN PATIO SOUTH)
(MOVE KITCHEN PATIO SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the patio door, revealing the backyard.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 1==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        """Agent is at location loc"""
        pass

    # Predicate: door is closed
    @predicate(Door)
    def door_closed(self, d):
        """Door d is closed"""
        pass

    # Predicate: door d is the south door
    @predicate(Door)
    def south_door(self, d):
        """Door d is the door to the south"""
        pass

    # Predicate: door d is the west door
    @predicate(Door)
    def west_door(self, d):
        """Door d is the door to the west"""
        pass

    # Predicate: door d connects location loc_from to loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        """Door d connects loc_from to loc_to"""
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door from a source location to a destination
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door from a source location to a destination
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect


[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Create objects for locations: the observed kitchen, and the rooms behind the doors
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "patio", "room_west"])
        # Create objects for doors: one to the south (patio door) and one to the west (plain door)
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door"])

    @init
    def init(self):
        init_state = [
            # Agent is initially in the kitchen
            self.at(self.locationObjs["kitchen"]),
            
            # Both doors are observed to be closed
            self.door_closed(self.doorObjs["south_door"]),
            self.door_closed(self.doorObjs["west_door"]),
            
            # Indicate the direction of each door
            self.south_door(self.doorObjs["south_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity: the south door connects the kitchen to the patio,
            # and the west door connects the kitchen to an unvisited room (room_west)
            self.connects(self.locationObjs["kitchen"], self.doorObjs["south_door"], self.locationObjs["patio"]),
            self.connects(self.locationObjs["kitchen"], self.doorObjs["west_door"], self.locationObjs["room_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to be in a location other than the kitchen; here we choose the patio
        return [self.at(self.locationObjs["patio"])]


### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen patio room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (closed kitchen patio south)
    (closed kitchen room_west west)
    (connected kitchen patio south)
    (connected kitchen room_west west)
  )
  (:goal (at patio))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        """Agent is at location loc"""
        pass

    # Predicate: door is closed
    @predicate(Door)
    def door_closed(self, d):
        """Door d is closed"""
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        """Door d is a door to the south"""
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        """Door d is a door to the west"""
        pass

    # Predicate: door d connects location loc_from to location loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        """Door d connects loc_from to loc_to"""
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door from a source location to a destination
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door from a source location to a destination
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define location objects based on current observations
        # Locations: kitchen, backyard (revealed by the opened patio door), driveway (to the south), backyard_west (to the west), and street (to the east)
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        
        # Define door objects
        # 'south_door': the patio door between kitchen and backyard (already opened)
        # 'west_door': the patio door to the west from the backyard (currently closed)
        # 'driveway_door': a door to the south from the backyard leading to the driveway (currently closed)
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door", "driveway_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the backyard after moving south
            self.at(self.locationObjs["backyard"]),
            
            # The patio door between kitchen and backyard is open (note: door_closed is not asserted for an open door)
            self.south_door(self.doorObjs["south_door"]),
            
            # The driveway door (south door from backyard to driveway) is initially closed
            self.door_closed(self.doorObjs["driveway_door"]),
            self.south_door(self.doorObjs["driveway_door"]),
            
            # The west door from the backyard is closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts
            # The opened patio door connects the kitchen to the backyard
            self.connects(self.locationObjs["kitchen"], self.doorObjs["south_door"], self.locationObjs["backyard"]),
            
            # The driveway door connects the backyard to the driveway
            self.connects(self.locationObjs["backyard"], self.doorObjs["driveway_door"], self.locationObjs["driveway"]),
            
            # The west door connects the backyard to a new location to the west
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore a new location; here, the driveway has not been visited yet
        return [self.at(self.locationObjs["driveway"])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen patio room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (closed kitchen patio south)
    (closed kitchen room_west west)
    (connected kitchen patio south)
    (connected kitchen room_west west)
  )
  (:goal (at patio))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        """Agent is at location loc"""
        pass

    # Predicate: door is closed
    @predicate(Door)
    def door_closed(self, d):
        """Door d is closed"""
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        """Door d is a door to the south"""
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        """Door d is a door to the west"""
        pass

    # Predicate: door d connects location loc_from to location loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        """Door d connects loc_from to loc_to"""
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door from a source location to a destination
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door from a source location to a destination
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define location objects based on current observations
        # Locations: kitchen, backyard (revealed by the opened patio door), driveway (to the south), backyard_west (to the west), and street (to the east)
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        
        # Define door objects
        # 'south_door': the patio door between kitchen and backyard (already opened)
        # 'west_door': the patio door to the west from the backyard (currently closed)
        # 'driveway_door': a door to the south from the backyard leading to the driveway (currently closed)
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door", "driveway_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the backyard after moving south
            self.at(self.locationObjs["backyard"]),
            
            # The patio door between kitchen and backyard is open (note: door_closed is not asserted for an open door)
            self.south_door(self.doorObjs["south_door"]),
            
            # The driveway door (south door from backyard to driveway) is initially closed
            self.door_closed(self.doorObjs["driveway_door"]),
            self.south_door(self.doorObjs["driveway_door"]),
            
            # The west door from the backyard is closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts
            # The opened patio door connects the kitchen to the backyard
            self.connects(self.locationObjs["kitchen"], self.doorObjs["south_door"], self.locationObjs["backyard"]),
            
            # The driveway door connects the backyard to the driveway
            self.connects(self.locationObjs["backyard"], self.doorObjs["driveway_door"], self.locationObjs["driveway"]),
            
            # The west door connects the backyard to a new location to the west
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore a new location; here, the driveway has not been visited yet
        return [self.at(self.locationObjs["driveway"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (connected kitchen backyard south)
    (connected backyard driveway south)
    (closed backyard driveway south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at driveway))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR BACKYARD DRIVEWAY SOUTH)
(MOVE BACKYARD DRIVEWAY SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        """Agent is at location loc"""
        pass

    # Predicate: door is closed
    @predicate(Door)
    def door_closed(self, d):
        """Door d is closed"""
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        """Door d is a door to the south"""
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        """Door d is a door to the west"""
        pass

    # Predicate: door d connects location loc_from to location loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        """Door d connects loc_from to loc_to"""
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door from a source location to a destination
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door from a source location to a destination
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define location objects based on current observations
        # Locations: kitchen, backyard (revealed by the opened patio door), driveway (to the south), backyard_west (to the west), and street (to the east)
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        
        # Define door objects
        # 'south_door': the patio door between kitchen and backyard (already opened)
        # 'west_door': the patio door to the west from the backyard (currently closed)
        # 'driveway_door': a door to the south from the backyard leading to the driveway (currently closed)
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door", "driveway_door"])

    @init
    def init(self):
        init_state = [
            # Agent is now in the backyard after moving south
            self.at(self.locationObjs["backyard"]),
            
            # The patio door between kitchen and backyard is open (note: door_closed is not asserted for an open door)
            self.south_door(self.doorObjs["south_door"]),
            
            # The driveway door (south door from backyard to driveway) is initially closed
            self.door_closed(self.doorObjs["driveway_door"]),
            self.south_door(self.doorObjs["driveway_door"]),
            
            # The west door from the backyard is closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts
            # The opened patio door connects the kitchen to the backyard
            self.connects(self.locationObjs["kitchen"], self.doorObjs["south_door"], self.locationObjs["backyard"]),
            
            # The driveway door connects the backyard to the driveway
            self.connects(self.locationObjs["backyard"], self.doorObjs["driveway_door"], self.locationObjs["driveway"]),
            
            # The west door connects the backyard to a new location to the west
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # The goal is to explore a new location; here, the driveway has not been visited yet
        return [self.at(self.locationObjs["driveway"])]

### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (connected kitchen backyard south)
    (connected backyard driveway south)
    (closed backyard driveway south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at driveway))
)
### Environment feedback (if any)
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity, e.g. move west)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # New predicate for direct connectivity without a door (used for moving south when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Updated Action: move south directly without a door
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define location objects
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        
        # Only the west door exists now since the observation indicates there is no door to the south
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the backyard
            self.at(self.locationObjs["backyard"]),

            # West door is present and is initially closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),

            # Direct connectivity from backyard to driveway (south movement without a door)
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),

            # Connectivity for moving west through the west door
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal is to explore the new location to the south (driveway)
        return [self.at(self.locationObjs["driveway"])]

--Small Loop--: 2 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (connected kitchen backyard south)
    (connected backyard driveway south)
    (closed backyard driveway south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at driveway))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity, e.g. move west)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # New predicate for direct connectivity without a door (used for moving south when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Updated Action: move south directly without a door
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect


### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define location objects
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        
        # Only the west door exists now since the observation indicates there is no door to the south
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the backyard
            self.at(self.locationObjs["backyard"]),

            # West door is present and is initially closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),

            # Direct connectivity from backyard to driveway (south movement without a door)
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),

            # Connectivity for moving west through the west door
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal is to explore the new location to the south (driveway)
        return [self.at(self.locationObjs["driveway"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (connected backyard driveway south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at driveway))
)
Actions from solver(df, pf): ['move south'] 
Raw plan text: (MOVE BACKYARD DRIVEWAY SOUTH)
 
Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 2==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity, e.g. move west)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # New predicate for direct connectivity without a door (used for moving south when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Updated Action: move south directly without a door
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect


[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define location objects
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        
        # Only the west door exists now since the observation indicates there is no door to the south
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the backyard
            self.at(self.locationObjs["backyard"]),

            # West door is present and is initially closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),

            # Direct connectivity from backyard to driveway (south movement without a door)
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),

            # Connectivity for moving west through the west door
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal is to explore the new location to the south (driveway)
        return [self.at(self.locationObjs["driveway"])]


### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (connected backyard driveway south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at driveway))
)
### Environment feedback (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity, e.g. move west)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate for direct connectivity without a door (used for moving south when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south directly without a door
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Previously observed locations and doors are preserved
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # The agent performed move_south and is now in the driveway
            self.at(self.locationObjs["driveway"]),
            
            # Door information from previous observations
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity fact observed during the move south action
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            
            # New connectivity: from driveway, the agent can move further south toward street (unvisited)
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # Connectivity for moving west from backyard to backyard_west (from earlier observation)
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: explore an unvisited location. Since the agent has been in backyard and driveway, target the new location street.
        return [self.at(self.locationObjs["street"])]
--Small Loop--: 1 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at backyard)
    (connected backyard driveway south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at driveway))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity, e.g. move west)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate for direct connectivity without a door (used for moving south when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south directly without a door
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Previously observed locations and doors are preserved
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # The agent performed move_south and is now in the driveway
            self.at(self.locationObjs["driveway"]),
            
            # Door information from previous observations
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity fact observed during the move south action
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            
            # New connectivity: from driveway, the agent can move further south toward street (unvisited)
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # Connectivity for moving west from backyard to backyard_west (from earlier observation)
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: explore an unvisited location. Since the agent has been in backyard and driveway, target the new location street.
        return [self.at(self.locationObjs["street"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)
Actions from solver(df, pf): ['move south'] 
Raw plan text: (MOVE DRIVEWAY STREET SOUTH)
 
Current action_queue: ['move south'] 
> move south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity, e.g. move west)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate for direct connectivity without a door (used for moving south when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south directly without a door
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Previously observed locations and doors are preserved
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # The agent performed move_south and is now in the driveway
            self.at(self.locationObjs["driveway"]),
            
            # Door information from previous observations
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity fact observed during the move south action
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            
            # New connectivity: from driveway, the agent can move further south toward street (unvisited)
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # Connectivity for moving west from backyard to backyard_west (from earlier observation)
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: explore an unvisited location. Since the agent has been in backyard and driveway, target the new location street.
        return [self.at(self.locationObjs["street"])]

### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)
### Environment feedback (if any)
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate for direct connectivity without a door
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door", "south_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at driveway
            self.at(self.locationObjs["driveway"]),
            # Previously observed west door is closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            # Connectivity fact from backyard to driveway (direct connectivity)
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            # Setup for south door connectivity: the door is initially closed
            self.south_door(self.doorObjs["south_door"]),
            self.door_closed(self.doorObjs["south_door"]),
            self.connects(self.locationObjs["driveway"], self.doorObjs["south_door"], self.locationObjs["street"]),
            # Connectivity for moving west from backyard to backyard_west
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: explore the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]
--Small Loop--: 2 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?dir - direction)
    (connected ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate for direct connectivity without a door
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door", "south_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at driveway
            self.at(self.locationObjs["driveway"]),
            # Previously observed west door is closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            # Connectivity fact from backyard to driveway (direct connectivity)
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            # Setup for south door connectivity: the door is initially closed
            self.south_door(self.doorObjs["south_door"]),
            self.door_closed(self.doorObjs["south_door"]),
            self.connects(self.locationObjs["driveway"], self.doorObjs["south_door"], self.locationObjs["street"]),
            # Connectivity for moving west from backyard to backyard_west
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: explore the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (closed driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR DRIVEWAY STREET SOUTH)
(MOVE DRIVEWAY STREET SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define the types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (used for door-based connectivity)
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate for direct connectivity without a door
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south through an open south door
    @action(Location, Door, Location)
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open west door
    @action(Location, Door, Location)
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door", "south_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at driveway
            self.at(self.locationObjs["driveway"]),
            # Previously observed west door is closed
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            # Connectivity fact from backyard to driveway (direct connectivity)
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            # Setup for south door connectivity: the door is initially closed
            self.south_door(self.doorObjs["south_door"]),
            self.door_closed(self.doorObjs["south_door"]),
            self.connects(self.locationObjs["driveway"], self.doorObjs["south_door"], self.locationObjs["street"]),
            # Connectivity for moving west from backyard to backyard_west
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: explore the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (closed driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)
### Environment feedback (if any)
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (door-based connectivity)
    @predicate("Location", "Door", "Location")
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (no door required)
    @predicate("Location", "Location")
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Updated Action: move south directly when there is no south door
    @action("Location", "Location")
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Only the west door is present in this instance; observations indicate no door exists to the south
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts
            # Existing direct connectivity
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            # For moving south, since there is no door, we use direct connectivity
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # Connectivity for moving west through the door
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]
--Small Loop--: 3 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction)
  )
  
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (closed driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (door-based connectivity)
    @predicate("Location", "Door", "Location")
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (no door required)
    @predicate("Location", "Location")
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Updated Action: move south directly when there is no south door
    @action("Location", "Location")
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Only the west door is present in this instance; observations indicate no door exists to the south
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts
            # Existing direct connectivity
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            # For moving south, since there is no door, we use direct connectivity
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # Connectivity for moving west through the door
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)
Actions from solver(df, pf): ['move south'] 
Raw plan text: (MOVE DRIVEWAY STREET SOUTH)
 
Current action_queue: ['move south'] 
> move south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 

----Larger Loop No. 3---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (door-based connectivity)
    @predicate("Location", "Door", "Location")
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (no door required)
    @predicate("Location", "Location")
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Updated Action: move south directly when there is no south door
    @action("Location", "Location")
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Only the west door is present in this instance; observations indicate no door exists to the south
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts
            # Existing direct connectivity
            self.direct_connects(self.locationObjs["backyard"], self.locationObjs["driveway"]),
            # For moving south, since there is no door, we use direct connectivity
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # Connectivity for moving west through the door
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)
### Environment feedback (if any)
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (door-based connectivity)
    @predicate("Location", "Door", "Location")
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (not used for door-based moves)
    @predicate("Location", "Location")
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south via door
    @action("Location", "Door", "Location")
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Define doors: south door and west door
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            
            # South door facts
            self.door_closed(self.doorObjs["south_door"]),
            self.south_door(self.doorObjs["south_door"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts for door-based movements
            self.connects(self.locationObjs["driveway"], self.doorObjs["south_door"], self.locationObjs["street"]),
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]
--Small Loop--: 4 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir))
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))
  )
)

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction
  )
  (:init
    (at driveway)
    (connected backyard driveway south)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west)
  )
  (:goal (at street))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (door-based connectivity)
    @predicate("Location", "Door", "Location")
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (not used for door-based moves)
    @predicate("Location", "Location")
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south via door
    @action("Location", "Door", "Location")
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Define doors: south door and west door
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            
            # South door facts
            self.door_closed(self.doorObjs["south_door"]),
            self.south_door(self.doorObjs["south_door"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts for door-based movements
            self.connects(self.locationObjs["driveway"], self.doorObjs["south_door"], self.locationObjs["street"]),
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction))

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir)))

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))))

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction)
  (:init
    (at driveway)
    (connected driveway street south)
    (closed driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west))
  (:goal (at street)))
Actions from solver(df, pf): ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR DRIVEWAY STREET SOUTH)
(MOVE DRIVEWAY STREET SOUTH)
 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 4---- 
successful_actions: ['open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door d connects loc_from to loc_to (door-based connectivity)
    @predicate("Location", "Door", "Location")
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (not used for door-based moves)
    @predicate("Location", "Location")
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south via door
    @action("Location", "Door", "Location")
    def move_south(self, src, d, dest):
        precond = [self.at(src), self.south_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west through an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

[py_problem]
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Define doors: south door and west door
        self.doorObjs = ExplorerDomain.Door.create_objs(["south_door", "west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            
            # South door facts
            self.door_closed(self.doorObjs["south_door"]),
            self.south_door(self.doorObjs["south_door"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            
            # Connectivity facts for door-based movements
            self.connects(self.locationObjs["driveway"], self.doorObjs["south_door"], self.locationObjs["street"]),
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

### Previous PDDL (edit minimally)
[df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction))

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir)))

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))))

[pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction)
  (:init
    (at driveway)
    (connected driveway street south)
    (closed driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west))
  (:goal (at street)))
### Environment feedback (if any)
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door-based connectivity: door d connects loc_from to loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (used when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south (remains defined but will be inapplicable if no south door exists)
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south directly (without a door, as none exists in the south direction)
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west via an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect
Generated py_problem:
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Only the west door exists in this environment; south door has been removed as per observation
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            # Direct connectivity for moving south where no door is present
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            # Connectivity for west door-based movement
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]
--Small Loop--: 5 
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction))

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir)))

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))))

[Problem file]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction)
  (:init
    (at driveway)
    (connected driveway street south)
    (closed driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west))
  (:goal (at street)))

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorerDomain(Domain):
    # Define types
    Location = create_type("Location")
    Door = create_type("Door")

    # Predicate: agent is at a given location
    @predicate(Location)
    def at(self, loc):
        pass

    # Predicate: a door is closed
    @predicate(Door)
    def door_closed(self, d):
        pass

    # Predicate: door d is a door to the south
    @predicate(Door)
    def south_door(self, d):
        pass

    # Predicate: door d is a door to the west
    @predicate(Door)
    def west_door(self, d):
        pass

    # Predicate: door-based connectivity: door d connects loc_from to loc_to
    @predicate(Location, Door, Location)
    def connects(self, loc_from, d, loc_to):
        pass

    # Predicate: direct connectivity between locations (used when no door exists)
    @predicate(Location, Location)
    def direct_connects(self, src, dest):
        pass

    # Action: open door to south (remains defined but will be inapplicable if no south door exists)
    @action(Door)
    def open_door_south(self, d):
        precond = [self.south_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to south
    @action(Door)
    def close_door_south(self, d):
        precond = [self.south_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: open door to west
    @action(Door)
    def open_door_west(self, d):
        precond = [self.west_door(d), self.door_closed(d)]
        effect = [~self.door_closed(d)]
        return precond, effect

    # Action: close door to west
    @action(Door)
    def close_door_west(self, d):
        precond = [self.west_door(d), ~self.door_closed(d)]
        effect = [self.door_closed(d)]
        return precond, effect

    # Action: move south directly (without a door, as none exists in the south direction)
    @action(Location, Location)
    def move_south(self, src, dest):
        precond = [self.at(src), self.direct_connects(src, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

    # Action: move west via an open door
    @action("Location", "Door", "Location")
    def move_west(self, src, d, dest):
        precond = [self.at(src), self.west_door(d), ~self.door_closed(d), self.connects(src, d, dest)]
        effect = [~self.at(src), self.at(dest)]
        return precond, effect

### Python IR: problem class
from py2pddl import init, goal

class ExplorerProblem(ExplorerDomain):
    def __init__(self):
        super().__init__()
        # Define the locations in the environment
        self.locationObjs = ExplorerDomain.Location.create_objs(["kitchen", "backyard", "driveway", "backyard_west", "street"])
        # Only the west door exists in this environment; south door has been removed as per observation
        self.doorObjs = ExplorerDomain.Door.create_objs(["west_door"])

    @init
    def init(self):
        init_state = [
            # Agent starts at the driveway
            self.at(self.locationObjs["driveway"]),
            # Direct connectivity for moving south where no door is present
            self.direct_connects(self.locationObjs["driveway"], self.locationObjs["street"]),
            
            # West door facts
            self.door_closed(self.doorObjs["west_door"]),
            self.west_door(self.doorObjs["west_door"]),
            # Connectivity for west door-based movement
            self.connects(self.locationObjs["backyard"], self.doorObjs["west_door"], self.locationObjs["backyard_west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: reach the unvisited location 'street'
        return [self.at(self.locationObjs["street"])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain explorer)
  (:requirements :strips :typing)
  (:types location direction)
  (:predicates
    (at ?l - location)
    (closed ?loc1 - location ?loc2 - location ?d - direction)
    (connected ?loc1 - location ?loc2 - location ?d - direction))

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and (at ?loc1) (connected ?loc1 ?loc2 ?dir) (closed ?loc1 ?loc2 ?dir))
    :effect (not (closed ?loc1 ?loc2 ?dir)))

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and (at ?from) (connected ?from ?to ?dir) (not (closed ?from ?to ?dir)))
    :effect (and (not (at ?from)) (at ?to))))

[PDDL pf]
(define (problem explorer_problem)
  (:domain explorer)
  (:objects
    kitchen backyard driveway backyard_west street - location
    south west - direction)
  (:init
    (at driveway)
    (connected driveway street south)
    (connected backyard backyard_west west)
    (closed backyard backyard_west west))
  (:goal (at street)))
Actions from solver(df, pf): ['move south'] 
Raw plan text: (MOVE DRIVEWAY STREET SOUTH)
 
Current action_queue: ['move south'] 
> move south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: move south. You cannot move to that direction. Review the predicate of your actions and the problem files to check the status. 
