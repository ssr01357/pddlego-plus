Observations: You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
To the South you see a closed patio door. To the West you see a closed plain door.  
Gold path: ['look around', 'open door to south', 'open door to west', 'move south', 'open door to west', 'move east', 'open door to north', 'move north', 'take coin'] 
Valid Actions: ['look around', 'close door to west', 'move west', 'open door to south', 'open door to west', 'inventory', 'move south', 'close door to south'] 
taskDescription: Your task is to search the environment and find the coin.  Once you find the coin, take it. 
brief_obs: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 
 


====Step 0==== 

----Larger Loop No. 0---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in a direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class KitchenInitial(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "unknown_room_south", "unknown_room_west"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["door_south", "door_west"])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            self.closed(self.doorObjs["door_south"]),
            self.closed(self.doorObjs["door_west"]),
            self.door_between(self.doorObjs["door_south"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_south"], self.dirObjs["south"]),
            self.door_between(self.doorObjs["door_west"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_west"], self.dirObjs["west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit a not-yet-visited room (either south or west)
        return [
            self.visited(self.roomObjs["unknown_room_south"]) | self.visited(self.roomObjs["unknown_room_west"])
        ]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
N/A

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in a direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class KitchenInitial(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "unknown_room_south", "unknown_room_west"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["door_south", "door_west"])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            self.closed(self.doorObjs["door_south"]),
            self.closed(self.doorObjs["door_west"]),
            self.door_between(self.doorObjs["door_south"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_south"], self.dirObjs["south"]),
            self.door_between(self.doorObjs["door_west"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_west"], self.dirObjs["west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit a not-yet-visited room (either south or west)
        return [
            self.visited(self.roomObjs["unknown_room_south"]) | self.visited(self.roomObjs["unknown_room_west"])
        ]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem kitchen-initial)
  (:domain exploration)
  (:objects
    kitchen unknown_room_south unknown_room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)
    (door-closed kitchen unknown_room_south south)
    (door-closed kitchen unknown_room_west west)
    (door-between kitchen unknown_room_south south)
    (door-between kitchen unknown_room_west west)
  )
  (:goal (or (visited unknown_room_south) (visited unknown_room_west)))
)

Actions from solver: ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR KITCHEN UNKNOWN_ROOM_WEST WEST)
(MOVE KITCHEN UNKNOWN_ROOM_WEST WEST)
(REACH-GOAL)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 6 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: KITCHEN-INITIAL
	#Actions: 6
	#Fluents: 10
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[1 / 3]--
--[0 / 0]--
--[0 / 4]--
Total time: 0.000176
Nodes generated during search: 8
Nodes expanded during search: 4
Plan found with cost: 3
Fast-BFS search completed in 0.000176 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_m3nec6ud/plan_tmp.txt
Bad plan description!


Failed plans:
 /tmp/pddl_run_m3nec6ud/plan_tmp.txt

Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the plain door, revealing the pantry.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the pantry. In one part of the room you see a folding chair, that has nothing on it. There is also a shelf, that has nothing on it. 
Through an open plain door, to the East you see the kitchen.  


====Step 1==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
You open the plain door, revealing the pantry. 

Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in a direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class KitchenInitial(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "unknown_room_south", "unknown_room_west"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["door_south", "door_west"])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "west"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            self.closed(self.doorObjs["door_south"]),
            self.closed(self.doorObjs["door_west"]),
            self.door_between(self.doorObjs["door_south"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_south"], self.dirObjs["south"]),
            self.door_between(self.doorObjs["door_west"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_west"], self.dirObjs["west"])
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit a not-yet-visited room (either south or west)
        return [
            self.visited(self.roomObjs["unknown_room_south"]) | self.visited(self.roomObjs["unknown_room_west"])
        ]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem kitchen-initial)
  (:domain exploration)
  (:objects
    kitchen unknown_room_south unknown_room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)
    (door-closed kitchen unknown_room_south south)
    (door-closed kitchen unknown_room_west west)
    (door-between kitchen unknown_room_south south)
    (door-between kitchen unknown_room_west west)
  )
  (:goal (or (visited unknown_room_south) (visited unknown_room_west)))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in a direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class KitchenToPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "pantry", "unknown_room_south"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["door_south", "door_west"])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "west", "east"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.closed(self.doorObjs["door_south"]),
            self.open(self.doorObjs["door_west"]),
            # door_west leads from kitchen to pantry to the west
            self.door_between(self.doorObjs["door_west"], self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            # door_west leads from pantry to kitchen to the east
            self.door_between(self.doorObjs["door_west"], self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.doorObjs["door_south"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_south"], self.dirObjs["south"]),
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit a not-yet-visited room (only unknown_room_south left)
        return [
            self.visited(self.roomObjs["unknown_room_south"])
        ]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
You open the plain door, revealing the pantry. 

Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem kitchen-initial)
  (:domain exploration)
  (:objects
    kitchen unknown_room_south unknown_room_west - location
    south west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)
    (door-closed kitchen unknown_room_south south)
    (door-closed kitchen unknown_room_west west)
    (door-between kitchen unknown_room_south south)
    (door-between kitchen unknown_room_west west)
  )
  (:goal (or (visited unknown_room_south) (visited unknown_room_west)))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in a direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class KitchenToPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "pantry", "unknown_room_south"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["door_south", "door_west"])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "west", "east"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.closed(self.doorObjs["door_south"]),
            self.open(self.doorObjs["door_west"]),
            # door_west leads from kitchen to pantry to the west
            self.door_between(self.doorObjs["door_west"], self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            # door_west leads from pantry to kitchen to the east
            self.door_between(self.doorObjs["door_west"], self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.doorObjs["door_south"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_south"], self.dirObjs["south"]),
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit a not-yet-visited room (only unknown_room_south left)
        return [
            self.visited(self.roomObjs["unknown_room_south"])
        ]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem kitchen-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry unknown_room_south - location
    south west east - direction
  )
  (:init
    (at pantry)
    (visited kitchen)
    (visited pantry)
    (door-closed kitchen unknown_room_south south)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen unknown_room_south south)
  )
  (:goal (visited unknown_room_south))
)

Actions from solver: ['move east', 'open door to south', 'move south'] 
Raw plan text: (MOVE PANTRY KITCHEN EAST)
(OPEN-DOOR KITCHEN UNKNOWN_ROOM_SOUTH SOUTH)
(MOVE KITCHEN UNKNOWN_ROOM_SOUTH SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: KITCHEN-TO-PANTRY
	#Actions: 4
	#Fluents: 6
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[1 / 2]--
--[0 / 0]--
--[0 / 4]--
Total time: 0.000166
Nodes generated during search: 6
Nodes expanded during search: 4
Plan found with cost: 3
Fast-BFS search completed in 0.000166 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_wcfnqerr/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 3 

Successful plans:
Value: 3
 /tmp/pddl_run_wcfnqerr/plan_tmp.txt 3

Current action_queue: ['move east', 'open door to south', 'move south'] 
> move east 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
To the South you see a closed patio door. Through an open plain door, to the West you see the pantry.  
Small Loop, action_queue: ['open door to south', 'move south'] 
Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the patio door, revealing the backyard.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 2==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the kitchen. To the South you see a closed patio door. Through an open plain door, to the West you see the pantry. 

Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in a direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class KitchenToPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(["kitchen", "pantry", "unknown_room_south"])
        self.doorObjs = ExplorationDomain.Door.create_objs(["door_south", "door_west"])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "west", "east"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.closed(self.doorObjs["door_south"]),
            self.open(self.doorObjs["door_west"]),
            # door_west leads from kitchen to pantry to the west
            self.door_between(self.doorObjs["door_west"], self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            # door_west leads from pantry to kitchen to the east
            self.door_between(self.doorObjs["door_west"], self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.doorObjs["door_south"], self.roomObjs["kitchen"], self.roomObjs["unknown_room_south"], self.dirObjs["south"]),
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit a not-yet-visited room (only unknown_room_south left)
        return [
            self.visited(self.roomObjs["unknown_room_south"])
        ]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem kitchen-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry unknown_room_south - location
    south west east - direction
  )
  (:init
    (at pantry)
    (visited kitchen)
    (visited pantry)
    (door-closed kitchen unknown_room_south south)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen unknown_room_south south)
  )
  (:goal (visited unknown_room_south))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class KitchenToBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "unknown_room_south", "unknown_room_east", "unknown_room_west", "driveway", "street"
        ])
        self.doorObjs = ExplorationDomain.Door.create_objs([
            "door_south_kitchen", "door_west_kitchen", "door_west_backyard", "door_south_backyard", "door_east_backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north", "west", "east"])

    @init
    def init(self):
        init_state = [
            # Agent is in backyard after move
            self.agent_at(self.roomObjs["backyard"]),
            # Visited rooms
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["backyard"]),
            # Door states
            self.open(self.doorObjs["door_south_kitchen"]),  # was opened
            self.open(self.doorObjs["door_west_kitchen"]),
            self.closed(self.doorObjs["door_west_backyard"]),
            self.closed(self.doorObjs["door_south_backyard"]),
            self.closed(self.doorObjs["door_east_backyard"]),
            # Connections
            # Pantry <-> Kitchen (west/east)
            self.door_between(self.doorObjs["door_west_kitchen"], self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.doorObjs["door_west_kitchen"], self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            # Kitchen <-> Backyard (south/north)
            self.door_between(self.doorObjs["door_south_kitchen"], self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.doorObjs["door_south_kitchen"], self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            # Backyard <-> Driveway (south) (not yet explored)
            self.door_between(self.doorObjs["door_south_backyard"], self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            # Backyard <-> Street (east) (not yet explored)
            self.door_between(self.doorObjs["door_east_backyard"], self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            # Backyard <-> Unknown room (west) (not yet explored, but a door exists)
            self.door_between(self.doorObjs["door_west_backyard"], self.roomObjs["backyard"], self.roomObjs["unknown_room_west"], self.dirObjs["west"]),
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit any not-yet-visited room directly accessible, e.g. driveway, street, unknown_room_west
        # Prioritize unexplored rooms, for example, driveway
        return [
            self.visited(self.roomObjs["driveway"])
        ]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the kitchen. To the South you see a closed patio door. Through an open plain door, to the West you see the pantry. 

Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem kitchen-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry unknown_room_south - location
    south west east - direction
  )
  (:init
    (at pantry)
    (visited kitchen)
    (visited pantry)
    (door-closed kitchen unknown_room_south south)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen unknown_room_south south)
  )
  (:goal (visited unknown_room_south))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class KitchenToBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "unknown_room_south", "unknown_room_east", "unknown_room_west", "driveway", "street"
        ])
        self.doorObjs = ExplorationDomain.Door.create_objs([
            "door_south_kitchen", "door_west_kitchen", "door_west_backyard", "door_south_backyard", "door_east_backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north", "west", "east"])

    @init
    def init(self):
        init_state = [
            # Agent is in backyard after move
            self.agent_at(self.roomObjs["backyard"]),
            # Visited rooms
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["backyard"]),
            # Door states
            self.open(self.doorObjs["door_south_kitchen"]),  # was opened
            self.open(self.doorObjs["door_west_kitchen"]),
            self.closed(self.doorObjs["door_west_backyard"]),
            self.closed(self.doorObjs["door_south_backyard"]),
            self.closed(self.doorObjs["door_east_backyard"]),
            # Connections
            # Pantry <-> Kitchen (west/east)
            self.door_between(self.doorObjs["door_west_kitchen"], self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.doorObjs["door_west_kitchen"], self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            # Kitchen <-> Backyard (south/north)
            self.door_between(self.doorObjs["door_south_kitchen"], self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.doorObjs["door_south_kitchen"], self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            # Backyard <-> Driveway (south) (not yet explored)
            self.door_between(self.doorObjs["door_south_backyard"], self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            # Backyard <-> Street (east) (not yet explored)
            self.door_between(self.doorObjs["door_east_backyard"], self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            # Backyard <-> Unknown room (west) (not yet explored, but a door exists)
            self.door_between(self.doorObjs["door_west_backyard"], self.roomObjs["backyard"], self.roomObjs["unknown_room_west"], self.dirObjs["west"]),
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit any not-yet-visited room directly accessible, e.g. driveway, street, unknown_room_west
        # Prioritize unexplored rooms, for example, driveway
        return [
            self.visited(self.roomObjs["driveway"])
        ]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)

[PDDL pf]
(define (problem kitchen-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard driveway street unknown_room_west - location
    south north west east - direction
  )
  (:init
    (at backyard)
    (visited kitchen)
    (visited pantry)
    (visited backyard)
    ;; Kitchen <-> Pantry
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    ;; Kitchen <-> Backyard
    (door-open kitchen backyard south)
    (door-closed backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    ;; Backyard <-> Driveway
    (door-closed backyard driveway south)
    (door-between backyard driveway south)
    ;; Backyard <-> Street
    (door-closed backyard street east)
    (door-between backyard street east)
    ;; Backyard <-> Unknown west
    (door-closed backyard unknown_room_west west)
    (door-between backyard unknown_room_west west)
  )
  (:goal (visited driveway))
)
Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR BACKYARD DRIVEWAY SOUTH)
(MOVE BACKYARD DRIVEWAY SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 11 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: KITCHEN-TO-BACKYARD
	#Actions: 11
	#Fluents: 17
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 3]--
Total time: 0.000129
Nodes generated during search: 10
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000129 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_0mdn2az8/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_0mdn2az8/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Door, Room, Room, Direction)
    def door_between(self, door, room_from, room_to, direction):
        """True iff door is between room_from and room_to in direction from room_from."""

    @predicate(Door)
    def open(self, door):
        """True iff the door is open."""

    @predicate(Door)
    def closed(self, door):
        """True iff the door is closed."""

    @action(Door)
    def open_door(self, door):
        precond = [self.closed(door)]
        effect = [~self.closed(door), self.open(door)]
        return precond, effect

    @action(Door)
    def close_door(self, door):
        precond = [self.open(door)]
        effect = [~self.open(door), self.closed(door)]
        return precond, effect

    @action(Room, Door, Room, Direction)
    def move(self, room_from, door, room_to, direction):
        precond = [self.agent_at(room_from),
                   self.door_between(door, room_from, room_to, direction),
                   self.open(door)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class KitchenToBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "unknown_room_south", "unknown_room_east", "unknown_room_west", "driveway", "street"
        ])
        self.doorObjs = ExplorationDomain.Door.create_objs([
            "door_south_kitchen", "door_west_kitchen", "door_west_backyard", "door_south_backyard", "door_east_backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north", "west", "east"])

    @init
    def init(self):
        init_state = [
            # Agent is in backyard after move
            self.agent_at(self.roomObjs["backyard"]),
            # Visited rooms
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["backyard"]),
            # Door states
            self.open(self.doorObjs["door_south_kitchen"]),  # was opened
            self.open(self.doorObjs["door_west_kitchen"]),
            self.closed(self.doorObjs["door_west_backyard"]),
            self.closed(self.doorObjs["door_south_backyard"]),
            self.closed(self.doorObjs["door_east_backyard"]),
            # Connections
            # Pantry <-> Kitchen (west/east)
            self.door_between(self.doorObjs["door_west_kitchen"], self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.doorObjs["door_west_kitchen"], self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            # Kitchen <-> Backyard (south/north)
            self.door_between(self.doorObjs["door_south_kitchen"], self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.doorObjs["door_south_kitchen"], self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            # Backyard <-> Driveway (south) (not yet explored)
            self.door_between(self.doorObjs["door_south_backyard"], self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            # Backyard <-> Street (east) (not yet explored)
            self.door_between(self.doorObjs["door_east_backyard"], self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            # Backyard <-> Unknown room (west) (not yet explored, but a door exists)
            self.door_between(self.doorObjs["door_west_backyard"], self.roomObjs["backyard"], self.roomObjs["unknown_room_west"], self.dirObjs["west"]),
        ]
        return init_state

    @goal
    def goal(self):
        # Goal: visit any not-yet-visited room directly accessible, e.g. driveway, street, unknown_room_west
        # Prioritize unexplored rooms, for example, driveway
        return [
            self.visited(self.roomObjs["driveway"])
        ]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)

[pf]
(define (problem kitchen-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard driveway street unknown_room_west - location
    south north west east - direction
  )
  (:init
    (at backyard)
    (visited kitchen)
    (visited pantry)
    (visited backyard)
    ;; Kitchen <-> Pantry
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    ;; Kitchen <-> Backyard
    (door-open kitchen backyard south)
    (door-closed backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    ;; Backyard <-> Driveway
    (door-closed backyard driveway south)
    (door-between backyard driveway south)
    ;; Backyard <-> Street
    (door-closed backyard street east)
    (door-between backyard street east)
    ;; Backyard <-> Unknown west
    (door-closed backyard unknown_room_west west)
    (door-between backyard unknown_room_west west)
  )
  (:goal (visited driveway))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class KitchenToBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "unknown_room_south", "unknown_room_east", "unknown_room_west", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north", "west", "east"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["backyard"]),
            # Connections known from observations (south from backyard is traversable, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["unknown_room_west"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
        ]
        return init_state

    @goal
    def goal(self):
        return [self.visited(self.roomObjs["driveway"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)

[Problem file]
(define (problem kitchen-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard driveway street unknown_room_west - location
    south north west east - direction
  )
  (:init
    (at backyard)
    (visited kitchen)
    (visited pantry)
    (visited backyard)
    ;; Kitchen <-> Pantry
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    ;; Kitchen <-> Backyard
    (door-open kitchen backyard south)
    (door-closed backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    ;; Backyard <-> Driveway
    (door-closed backyard driveway south)
    (door-between backyard driveway south)
    ;; Backyard <-> Street
    (door-closed backyard street east)
    (door-between backyard street east)
    ;; Backyard <-> Unknown west
    (door-closed backyard unknown_room_west west)
    (door-between backyard unknown_room_west west)
  )
  (:goal (visited driveway))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class KitchenToBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "unknown_room_south", "unknown_room_east", "unknown_room_west", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north", "west", "east"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["backyard"]),
            # Connections known from observations (south from backyard is traversable, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["unknown_room_west"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
        ]
        return init_state

    @goal
    def goal(self):
        return [self.visited(self.roomObjs["driveway"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (or (door-open ?from ?to ?dir)
          (and (not (door-closed ?from ?to ?dir))
               (not (door-open ?from ?to ?dir))
               )
      )
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem kitchen-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard unknown_room_south unknown_room_east unknown_room_west driveway street - location
    south north west east - direction
  )
  (:init
    (at backyard)
    (visited kitchen)
    (visited pantry)
    (visited backyard)
    (door-between backyard driveway south)
    (door-between backyard street east)
    (door-between backyard unknown_room_west west)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
  )
  (:goal (visited driveway))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE BACKYARD DRIVEWAY SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 7 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: KITCHEN-TO-BACKYARD
	#Actions: 7
	#Fluents: 9
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 8.19998e-05
Nodes generated during search: 5
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 8.19998e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_moz81bss/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_moz81bss/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 3==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class KitchenToBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "unknown_room_south", "unknown_room_east", "unknown_room_west", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north", "west", "east"])

    @init
    def init(self):
        init_state = [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["backyard"]),
            # Connections known from observations (south from backyard is traversable, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["unknown_room_west"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
        ]
        return init_state

    @goal
    def goal(self):
        return [self.visited(self.roomObjs["driveway"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (or (door-open ?from ?to ?dir)
          (and (not (door-closed ?from ?to ?dir))
               (not (door-open ?from ?to ?dir))
               )
      )
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem kitchen-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard unknown_room_south unknown_room_east unknown_room_west driveway street - location
    south north west east - direction
  )
  (:init
    (at backyard)
    (visited kitchen)
    (visited pantry)
    (visited backyard)
    (door-between backyard driveway south)
    (door-between backyard street east)
    (door-between backyard unknown_room_west west)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
  )
  (:goal (visited driveway))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north"])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["driveway"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"])
        ]

    @goal
    def goal(self):
        # Explore: require to visit a new, not previously visited location (but here both are visited by this step)
        # No further unvisited room revealed yet. Safest goal: agent_at backyard (next unexplored direction is north from driveway)
        return [self.agent_at(self.roomObjs["backyard"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (door-closed ?loc1 ?loc2 ?dir)
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (or (door-open ?from ?to ?dir)
          (and (not (door-closed ?from ?to ?dir))
               (not (door-open ?from ?to ?dir))
               )
      )
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem kitchen-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard unknown_room_south unknown_room_east unknown_room_west driveway street - location
    south north west east - direction
  )
  (:init
    (at backyard)
    (visited kitchen)
    (visited pantry)
    (visited backyard)
    (door-between backyard driveway south)
    (door-between backyard street east)
    (door-between backyard unknown_room_west west)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
  )
  (:goal (visited driveway))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north"])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["driveway"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"])
        ]

    @goal
    def goal(self):
        # Explore: require to visit a new, not previously visited location (but here both are visited by this step)
        # No further unvisited room revealed yet. Safest goal: agent_at backyard (next unexplored direction is north from driveway)
        return [self.agent_at(self.roomObjs["backyard"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    backyard driveway - location
    south north - direction
  )
  (:init
    (at driveway)
    (visited backyard)
    (visited driveway)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open backyard driveway south)
    (door-open driveway backyard north)
  )
  (:goal (at backyard))
)

Actions from solver: ['move north'] 
Raw plan text: (MOVE DRIVEWAY BACKYARD NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 2 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-BACKYARD
	#Actions: 2
	#Fluents: 2
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 0.000116
Nodes generated during search: 2
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000116 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_wqmmsm3n/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_wqmmsm3n/plan_tmp.txt 1

Current action_queue: ['move north'] 
> move north 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 4==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs(["south", "north"])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["driveway"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"])
        ]

    @goal
    def goal(self):
        # Explore: require to visit a new, not previously visited location (but here both are visited by this step)
        # No further unvisited room revealed yet. Safest goal: agent_at backyard (next unexplored direction is north from driveway)
        return [self.agent_at(self.roomObjs["backyard"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    backyard driveway - location
    south north - direction
  )
  (:init
    (at driveway)
    (visited backyard)
    (visited driveway)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open backyard driveway south)
    (door-open driveway backyard north)
  )
  (:goal (at backyard))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway", "kitchen", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["driveway"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"]),
            # Door to the kitchen (north) is open
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # Door to driveway (south) is open
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # No door needed for street (open access east)
            # West: closed patio door
            self.door_between(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen or street
        # Let's pick kitchen (north) as the goal to visit next
        return [self.visited(self.roomObjs["kitchen"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    backyard driveway - location
    south north - direction
  )
  (:init
    (at driveway)
    (visited backyard)
    (visited driveway)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open backyard driveway south)
    (door-open driveway backyard north)
  )
  (:goal (at backyard))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway", "kitchen", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["driveway"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"]),
            # Door to the kitchen (north) is open
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # Door to driveway (south) is open
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # No door needed for street (open access east)
            # West: closed patio door
            self.door_between(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen or street
        # Let's pick kitchen (north) as the goal to visit next
        return [self.visited(self.roomObjs["kitchen"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-kitchen)
  (:domain exploration)
  (:objects
    backyard driveway kitchen street west_room - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    (visited driveway)
    ;; Adjacencies are implicit, not represented in PDDL unless needed for domain.
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)
    (door-between backyard west_room west)
    (door-closed backyard west_room west)
  )
  (:goal (visited kitchen))
)

Actions from solver: ['move north'] 
Raw plan text: (MOVE BACKYARD KITCHEN NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 6 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-KITCHEN
	#Actions: 6
	#Fluents: 8
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000107
Nodes generated during search: 4
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000107 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_sufkrgv5/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_sufkrgv5/plan_tmp.txt 1

Current action_queue: ['move north'] 
> move north 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry.  


====Step 5==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway", "kitchen", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["driveway"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"]),
            # Door to the kitchen (north) is open
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # Door to driveway (south) is open
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # No door needed for street (open access east)
            # West: closed patio door
            self.door_between(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["west_room"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen or street
        # Let's pick kitchen (north) as the goal to visit next
        return [self.visited(self.roomObjs["kitchen"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-kitchen)
  (:domain exploration)
  (:objects
    backyard driveway kitchen street west_room - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    (visited driveway)
    ;; Adjacencies are implicit, not represented in PDDL unless needed for domain.
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)
    (door-between backyard west_room west)
    (door-closed backyard west_room west)
  )
  (:goal (visited kitchen))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry (west)
        return [self.visited(self.roomObjs["pantry"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-kitchen)
  (:domain exploration)
  (:objects
    backyard driveway kitchen street west_room - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    (visited driveway)
    ;; Adjacencies are implicit, not represented in PDDL unless needed for domain.
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)
    (door-between backyard west_room west)
    (door-closed backyard west_room west)
  )
  (:goal (visited kitchen))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry (west)
        return [self.visited(self.roomObjs["pantry"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard pantry - location
    north south west east - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)

    (door-open kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (visited pantry))
)

Actions from solver: ['move west'] 
Raw plan text: (MOVE KITCHEN PANTRY WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-PANTRY
	#Actions: 4
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000158
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000158 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_y8snnwnh/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_y8snnwnh/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 You are in the pantry. In one part of the room you see a folding chair, that has nothing on it. There is also a shelf, that has nothing on it. 
Through an open plain door, to the East you see the kitchen.  


====Step 6==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry (west)
        return [self.visited(self.roomObjs["pantry"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard pantry - location
    north south west east - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)

    (door-open kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (visited pantry))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen (east)
        return [self.visited(self.roomObjs["kitchen"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard pantry - location
    north south west east - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)

    (door-open kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (visited pantry))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen (east)
        return [self.visited(self.roomObjs["kitchen"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (door-between pantry kitchen east)
    (door-between kitchen pantry west)
    (door-open pantry kitchen east)
    (door-open kitchen pantry west)
  )
  (:goal (visited kitchen))
)

Actions from solver: ['move east'] 
Raw plan text: (MOVE PANTRY KITCHEN EAST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 2 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-PANTRY
	#Actions: 2
	#Fluents: 3
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.00011
Nodes generated during search: 2
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.00011 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_kqb7ld_6/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_kqb7ld_6/plan_tmp.txt 1

Current action_queue: ['move east'] 
> move east 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry.  


====Step 7==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen (east)
        return [self.visited(self.roomObjs["kitchen"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (door-between pantry kitchen east)
    (door-between kitchen pantry west)
    (door-open pantry kitchen east)
    (door-open kitchen pantry west)
  )
  (:goal (visited kitchen))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "east", "west", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            # Adjacency: kitchen <-> pantry (west/east)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            # Adjacency: kitchen <-> backyard (south)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),  # Assume 'north' is needed for reverse!
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs.get("north", "north")),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # No info about backyard->kitchen door state/north; but safe to leave it open for now
        ]

    @goal
    def goal(self):
        # Next unexplored: backyard (south)
        return [self.visited(self.roomObjs["backyard"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (door-between pantry kitchen east)
    (door-between kitchen pantry west)
    (door-open pantry kitchen east)
    (door-open kitchen pantry west)
  )
  (:goal (visited kitchen))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "east", "west", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            # Adjacency: kitchen <-> pantry (west/east)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            # Adjacency: kitchen <-> backyard (south)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),  # Assume 'north' is needed for reverse!
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs.get("north", "north")),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # No info about backyard->kitchen door state/north; but safe to leave it open for now
        ]

    @goal
    def goal(self):
        # Next unexplored: backyard (south)
        return [self.visited(self.roomObjs["backyard"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    east west south north - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)
    ;; kitchen <-> pantry (west/east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    ;; kitchen <-> backyard (south/north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
  )
  (:goal (visited backyard))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE KITCHEN BACKYARD SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 3 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-BACKYARD
	#Actions: 3
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000101
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000101 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_aoow73rb/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_aoow73rb/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 8==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "east", "west", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),
            # Adjacency: kitchen <-> pantry (west/east)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            # Adjacency: kitchen <-> backyard (south)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),  # Assume 'north' is needed for reverse!
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs.get("north", "north")),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # No info about backyard->kitchen door state/north; but safe to leave it open for now
        ]

    @goal
    def goal(self):
        # Next unexplored: backyard (south)
        return [self.visited(self.roomObjs["backyard"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    east west south north - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)
    ;; kitchen <-> pantry (west/east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    ;; kitchen <-> backyard (south/north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
  )
  (:goal (visited backyard))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            # backyard <-> kitchen (north/south, open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> driveway (south, door present, assume closed by available actions)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_closed(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # backyard <-> street (east, no door mentioned, thus open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown, so do not introduce a room yet)
            # Only define possibility to interact with door to west from backyard, destination undefined
            # self.door_between(self.roomObjs["backyard"], ?, self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),  # Surrogate; destination unknown
        ]

    @goal
    def goal(self):
        # Next unexplored: driveway, street
        return [self.visited(self.roomObjs["driveway"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    east west south north - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)
    ;; kitchen <-> pantry (west/east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    ;; kitchen <-> backyard (south/north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
  )
  (:goal (visited backyard))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            # backyard <-> kitchen (north/south, open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> driveway (south, door present, assume closed by available actions)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_closed(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # backyard <-> street (east, no door mentioned, thus open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown, so do not introduce a room yet)
            # Only define possibility to interact with door to west from backyard, destination undefined
            # self.door_between(self.roomObjs["backyard"], ?, self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),  # Surrogate; destination unknown
        ]

    @goal
    def goal(self):
        # Next unexplored: driveway, street
        return [self.visited(self.roomObjs["driveway"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    ;; backyard <-> kitchen (north/south, open patio door)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> driveway (south, closed by default)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-closed backyard driveway south)
    (door-closed driveway backyard north)
    ;; Door to west exists but destination unknown (self-loop as surrogate, closed)
    (door-closed backyard backyard west)
  )
  (:goal (visited driveway))
)

Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR BACKYARD DRIVEWAY SOUTH)
(MOVE BACKYARD DRIVEWAY SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 6 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-DRIVEWAY
	#Actions: 6
	#Fluents: 9
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 3]--
Total time: 0.00011
Nodes generated during search: 7
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.00011 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_qx70md2t/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_qx70md2t/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   self.door_between(room_from, room_to, direction),
                   self.door_open(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            # backyard <-> kitchen (north/south, open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> driveway (south, door present, assume closed by available actions)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_closed(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # backyard <-> street (east, no door mentioned, thus open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown, so do not introduce a room yet)
            # Only define possibility to interact with door to west from backyard, destination undefined
            # self.door_between(self.roomObjs["backyard"], ?, self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),  # Surrogate; destination unknown
        ]

    @goal
    def goal(self):
        # Next unexplored: driveway, street
        return [self.visited(self.roomObjs["driveway"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    ;; backyard <-> kitchen (north/south, open patio door)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> driveway (south, closed by default)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-closed backyard driveway south)
    (door-closed driveway backyard north)
    ;; Door to west exists but destination unknown (self-loop as surrogate, closed)
    (door-closed backyard backyard west)
  )
  (:goal (visited driveway))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        # If there is a door between, it must be open
        precond_door = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        # Need to check if a door exists: if so, must be open, if not, just adjacency enough.
        # Assume in actual grounding: if door_between does not hold, precond_door is false so those atoms are dropped
        # For IR, must enumerate both. We produce two duplicates, one with and one without door_between.
        # But here, keep for full generalization: only require door to be open if there IS a door.
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond + effect[:0], effect  # precond_door not included unless relevant in problem/init

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            # backyard <-> kitchen (north/south, open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> driveway (south, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # backyard <-> street (east, no door mentioned, thus open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown, so do not introduce a room yet)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),  # Surrogate; destination unknown
        ]

    @goal
    def goal(self):
        # Next unexplored: driveway, street
        return [self.visited(self.roomObjs["driveway"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (door-between ?from ?to ?dir)
      (door-open ?from ?to ?dir)
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    ;; backyard <-> kitchen (north/south, open patio door)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> driveway (south, closed by default)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-closed backyard driveway south)
    (door-closed driveway backyard north)
    ;; Door to west exists but destination unknown (self-loop as surrogate, closed)
    (door-closed backyard backyard west)
  )
  (:goal (visited driveway))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        # If there is a door between, it must be open
        precond_door = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        # Need to check if a door exists: if so, must be open, if not, just adjacency enough.
        # Assume in actual grounding: if door_between does not hold, precond_door is false so those atoms are dropped
        # For IR, must enumerate both. We produce two duplicates, one with and one without door_between.
        # But here, keep for full generalization: only require door to be open if there IS a door.
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond + effect[:0], effect  # precond_door not included unless relevant in problem/init

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            # backyard <-> kitchen (north/south, open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> driveway (south, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # backyard <-> street (east, no door mentioned, thus open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown, so do not introduce a room yet)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),  # Surrogate; destination unknown
        ]

    @goal
    def goal(self):
        # Next unexplored: driveway, street
        return [self.visited(self.roomObjs["driveway"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    ;; backyard <-> kitchen (north/south, open patio door)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> driveway (south, NO DOOR: only adjacency)
    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    ;; backyard <-> street (east, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> ??? (west, closed patio door, use self-loop as surrogate)
    (door-closed backyard backyard west)
  )
  (:goal (visited driveway))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE BACKYARD DRIVEWAY SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 6 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-DRIVEWAY
	#Actions: 6
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.00011
Nodes generated during search: 4
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.00011 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_5a8znzqa/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_5a8znzqa/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 9==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        # If there is a door between, it must be open
        precond_door = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        # Need to check if a door exists: if so, must be open, if not, just adjacency enough.
        # Assume in actual grounding: if door_between does not hold, precond_door is false so those atoms are dropped
        # For IR, must enumerate both. We produce two duplicates, one with and one without door_between.
        # But here, keep for full generalization: only require door to be open if there IS a door.
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond + effect[:0], effect  # precond_door not included unless relevant in problem/init

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),
            # backyard <-> kitchen (north/south, open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> driveway (south, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            # backyard <-> street (east, no door mentioned, thus open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown, so do not introduce a room yet)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),  # Surrogate; destination unknown
        ]

    @goal
    def goal(self):
        # Next unexplored: driveway, street
        return [self.visited(self.roomObjs["driveway"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    ;; backyard <-> kitchen (north/south, open patio door)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> driveway (south, NO DOOR: only adjacency)
    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    ;; backyard <-> street (east, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> ??? (west, closed patio door, use self-loop as surrogate)
    (door-closed backyard backyard west)
  )
  (:goal (visited driveway))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),
            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            # We still need to represent backyard adjacencies for south, east, and west (as in previous knowledge)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> kitchen (north/south, with open door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen, street
        return [self.visited(self.roomObjs["street"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    ;; backyard <-> kitchen (north/south, open patio door)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> driveway (south, NO DOOR: only adjacency)
    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    ;; backyard <-> street (east, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> ??? (west, closed patio door, use self-loop as surrogate)
    (door-closed backyard backyard west)
  )
  (:goal (visited driveway))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),
            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            # We still need to represent backyard adjacencies for south, east, and west (as in previous knowledge)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> kitchen (north/south, with open door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen, street
        return [self.visited(self.roomObjs["street"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at driveway)
    (visited driveway)
    ;; driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    ;; backyard <-> street (east/west, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> kitchen (north/south, with door open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> ??? (west, closed patio door, location behind unknown)
    (door-closed backyard backyard west)
  )
  (:goal (visited street))
)

Actions from solver: ['move north', 'move east'] 
Raw plan text: (MOVE DRIVEWAY BACKYARD NORTH)
(MOVE BACKYARD STREET EAST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 6 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-DRIVEWAY
	#Actions: 6
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 2]--
--[0 / 0]--
--[0 / 4]--
Total time: 0.000138
Nodes generated during search: 5
Nodes expanded during search: 2
Plan found with cost: 2
Fast-BFS search completed in 0.000138 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_250uqjzj/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_250uqjzj/plan_tmp.txt 2

Current action_queue: ['move north', 'move east'] 
> move north 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  
Small Loop, action_queue: ['move east'] 
Current action_queue: ['move east'] 
> move east 
 You are in the street. 
To the North you see a closed sliding door. To the West you see the backyard.  


====Step 10==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Action: move east
You are in the street. To the North you see a closed sliding door. To the West you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction)]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),
            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            # We still need to represent backyard adjacencies for south, east, and west (as in previous knowledge)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> kitchen (north/south, with open door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen, street
        return [self.visited(self.roomObjs["street"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at driveway)
    (visited driveway)
    ;; driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    ;; backyard <-> street (east/west, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> kitchen (north/south, with door open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> ??? (west, closed patio door, location behind unknown)
    (door-closed backyard backyard west)
  )
  (:goal (visited street))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepStreet(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["street"]),
            self.visited(self.roomObjs["street"]),
            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),

            # backyard <-> street (east/west, no door, open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with door open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen
        return [self.visited(self.roomObjs["kitchen"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Action: move east
You are in the street. To the North you see a closed sliding door. To the West you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at driveway)
    (visited driveway)
    ;; driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    ;; backyard <-> street (east/west, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> kitchen (north/south, with door open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> ??? (west, closed patio door, location behind unknown)
    (door-closed backyard backyard west)
  )
  (:goal (visited street))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepStreet(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["street"]),
            self.visited(self.roomObjs["street"]),
            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),

            # backyard <-> street (east/west, no door, open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with door open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen
        return [self.visited(self.roomObjs["kitchen"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at street)
    (visited street)
    ;; driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    ;; backyard <-> street (east/west, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> kitchen (north/south, with door open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> ??? (west, closed patio door, location behind unknown)
    (door-closed backyard backyard west)
    ;; street <-> ??? (north, closed sliding door, location behind unknown)
    (door-closed street street north)
  )
  (:goal (visited kitchen))
)

Actions from solver: ['move west', 'move north'] 
Raw plan text: (MOVE STREET BACKYARD WEST)
(MOVE BACKYARD KITCHEN NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 6 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-KITCHEN
	#Actions: 6
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 2]--
--[0 / 0]--
--[0 / 4]--
Total time: 0.000141
Nodes generated during search: 5
Nodes expanded during search: 2
Plan found with cost: 2
Fast-BFS search completed in 0.000141 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_k14lhlrs/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_k14lhlrs/plan_tmp.txt 2

Current action_queue: ['move west', 'move north'] 
> move west 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  
Small Loop, action_queue: ['move north'] 
Current action_queue: ['move north'] 
> move north 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry.  


====Step 11==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepStreet(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["street"]),
            self.visited(self.roomObjs["street"]),
            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),

            # backyard <-> street (east/west, no door, open passage)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with door open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen
        return [self.visited(self.roomObjs["kitchen"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at street)
    (visited street)
    ;; driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    ;; backyard <-> street (east/west, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> kitchen (north/south, with door open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> ??? (west, closed patio door, location behind unknown)
    (door-closed backyard backyard west)
    ;; street <-> ??? (north, closed sliding door, location behind unknown)
    (door-closed street street north)
  )
  (:goal (visited kitchen))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in kitchen
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown, not updated)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown, not updated)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry
        return [self.visited(self.roomObjs["pantry"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street - location
    north south east west - direction
  )
  (:init
    (at street)
    (visited street)
    ;; driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    ;; backyard <-> street (east/west, no door, open passage)
    (adjacent backyard street east)
    (adjacent street backyard west)
    ;; backyard <-> kitchen (north/south, with door open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    ;; backyard <-> ??? (west, closed patio door, location behind unknown)
    (door-closed backyard backyard west)
    ;; street <-> ??? (north, closed sliding door, location behind unknown)
    (door-closed street street north)
  )
  (:goal (visited kitchen))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in kitchen
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown, not updated)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown, not updated)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry
        return [self.visited(self.roomObjs["pantry"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)

Actions from solver: ['move west'] 
Raw plan text: (MOVE KITCHEN PANTRY WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 8 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-PANTRY
	#Actions: 8
	#Fluents: 6
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000105
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000105 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_6nk6vbql/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_6nk6vbql/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 You are in the pantry. In one part of the room you see a folding chair, that has nothing on it. There is also a shelf, that has nothing on it. 
Through an open plain door, to the East you see the kitchen.  


====Step 12==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in kitchen
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown, not updated)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown, not updated)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry
        return [self.visited(self.roomObjs["pantry"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry is visited
        return [self.visited(self.roomObjs["pantry"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry is visited
        return [self.visited(self.roomObjs["pantry"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (visited pantry)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)

Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to TRUE. The empty plan solves it
── VAL LOG ────────────────────────────────────
No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (visited pantry)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)


### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to TRUE. The empty plan solves it
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry is visited
        return [self.visited(self.roomObjs["pantry"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (visited pantry)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)

Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to TRUE. The empty plan solves it
── VAL LOG ────────────────────────────────────
No validation log.

[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "driveway", "street", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["street"]),
            self.visited(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["pantry"]),

            # driveway <-> backyard (north, NO DOOR: thus only adjacency, not door)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            
            # backyard <-> street (east/west, open, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> kitchen (north/south, with open patio door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # backyard <-> ??? (west, closed patio door, location behind unknown)
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # street <-> ??? (north, closed sliding door, location behind unknown)
            self.door_closed(self.roomObjs["street"], self.roomObjs["street"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: pantry is visited
        return [self.visited(self.roomObjs["pantry"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (visited pantry)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)

### Planner Error from previous PDDL (if any)
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to TRUE. The empty plan solves it
── VAL LOG ────────────────────────────────────
No validation log.

### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen is not visited in the initial state (not according to observation), so go to kitchen
        return [self.visited(self.roomObjs["kitchen"])]


--- Attempting to Plan (Small Loop Try #3) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen backyard driveway street pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited street)
    (visited driveway)
    (visited backyard)
    (visited kitchen)
    (visited pantry)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (adjacent backyard street east)
    (adjacent street backyard west)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
    (door-closed backyard backyard west)
    (door-closed street street north)
  )
  (:goal (visited pantry))
)


### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to TRUE. The empty plan solves it
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen is not visited in the initial state (not according to observation), so go to kitchen
        return [self.visited(self.roomObjs["kitchen"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)

    (door-between kitchen pantry west)
    (door-between pantry kitchen east)

    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (visited kitchen))
)

Actions from solver: ['move east'] 
Raw plan text: (MOVE PANTRY KITCHEN EAST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 2 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-PANTRY
	#Actions: 2
	#Fluents: 3
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 9.60001e-05
Nodes generated during search: 2
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 9.60001e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_4m75tufk/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_4m75tufk/plan_tmp.txt 1

Current action_queue: ['move east'] 
> move east 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry.  


====Step 13==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            # Agent currently in pantry
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        # Next unexplored: kitchen is not visited in the initial state (not according to observation), so go to kitchen
        return [self.visited(self.roomObjs["kitchen"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)

    (door-between kitchen pantry west)
    (door-between pantry kitchen east)

    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (visited kitchen))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # kitchen <-> backyard (south, patio door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # The next unexplored location is backyard
        return [self.visited(self.roomObjs["backyard"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)

    (door-between kitchen pantry west)
    (door-between pantry kitchen east)

    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (visited kitchen))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # kitchen <-> backyard (south, patio door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # The next unexplored location is backyard
        return [self.visited(self.roomObjs["backyard"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)
  )
  (:goal (visited backyard))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE KITCHEN BACKYARD SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-BACKYARD
	#Actions: 4
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 6.2e-05
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 6.2e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_42e0ch_7/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_42e0ch_7/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 14==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> pantry (west, plain door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),

            # kitchen <-> backyard (south, patio door, open)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
        ]

    @goal
    def goal(self):
        # The next unexplored location is backyard
        return [self.visited(self.roomObjs["backyard"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)
  )
  (:goal (visited backyard))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),

            # backyard <-> kitchen (north, patio door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> driveway (south, plain door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),

            # backyard <-> street (east, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> unknown room (west, patio door, closed)
            # We don't know the name of the room to the west, so we do not enumerate it here.
            self.door_between(self.roomObjs["backyard"], self.roomObjs["unknown_west"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["unknown_west"], self.roomObjs["backyard"], self.dirObjs["east"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["unknown_west"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["unknown_west"], self.roomObjs["backyard"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        return [self.visited(self.roomObjs["driveway"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-backyard)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)
  )
  (:goal (visited backyard))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),

            # backyard <-> kitchen (north, patio door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> driveway (south, plain door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),

            # backyard <-> street (east, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> unknown room (west, patio door, closed)
            # We don't know the name of the room to the west, so we do not enumerate it here.
            self.door_between(self.roomObjs["backyard"], self.roomObjs["unknown_west"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["unknown_west"], self.roomObjs["backyard"], self.dirObjs["east"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["unknown_west"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["unknown_west"], self.roomObjs["backyard"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        return [self.visited(self.roomObjs["driveway"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen pantry backyard driveway street unknown_west - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)

    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)

    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)

    (adjacent backyard street east)
    (adjacent street backyard west)

    (door-between backyard unknown_west west)
    (door-between unknown_west backyard east)
    (door-closed backyard unknown_west west)
    (door-closed unknown_west backyard east)
  )
  (:goal (visited driveway))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE BACKYARD DRIVEWAY SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 8 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-DRIVEWAY
	#Actions: 8
	#Fluents: 11
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 9.00002e-05
Nodes generated during search: 6
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 9.00002e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_hph4wxrk/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_hph4wxrk/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the driveway. 
To the North you see the backyard.  


====Step 15==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east', 'move south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard", "driveway", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),

            # backyard <-> kitchen (north, patio door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> driveway (south, plain door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),

            # backyard <-> street (east, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),

            # backyard <-> unknown room (west, patio door, closed)
            # We don't know the name of the room to the west, so we do not enumerate it here.
            self.door_between(self.roomObjs["backyard"], self.roomObjs["unknown_west"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["unknown_west"], self.roomObjs["backyard"], self.dirObjs["east"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["unknown_west"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["unknown_west"], self.roomObjs["backyard"], self.dirObjs["east"]),
        ]

    @goal
    def goal(self):
        return [self.visited(self.roomObjs["driveway"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen pantry backyard driveway street unknown_west - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)

    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)

    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)

    (adjacent backyard street east)
    (adjacent street backyard west)

    (door-between backyard unknown_west west)
    (door-between unknown_west backyard east)
    (door-closed backyard unknown_west west)
    (door-closed unknown_west backyard east)
  )
  (:goal (visited driveway))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard, which is already visited, so problem is trivial (you are at driveway - just observed)
        # Preserve goal structure for framework: Go to a not yet visited location if possible
        # Here, the observation is you are in the driveway, so goal is to visit any not-yet-visited location (none in universal knowledge, so goal is dummy: stay at driveway)
        return []


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    kitchen pantry backyard driveway street unknown_west - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)

    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)

    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)

    (adjacent backyard street east)
    (adjacent street backyard west)

    (door-between backyard unknown_west west)
    (door-between unknown_west backyard east)
    (door-closed backyard unknown_west west)
    (door-closed unknown_west backyard east)
  )
  (:goal (visited driveway))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard, which is already visited, so problem is trivial (you are at driveway - just observed)
        # Preserve goal structure for framework: Go to a not yet visited location if possible
        # Here, the observation is you are in the driveway, so goal is to visit any not-yet-visited location (none in universal knowledge, so goal is dummy: stay at driveway)
        return []


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and))
)

Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    warning: empty con/disjunction in domain definition. simplifying.


ff: goal can be simplified to TRUE. The empty plan solves it
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and))
)


### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    warning: empty con/disjunction in domain definition. simplifying.


ff: goal can be simplified to TRUE. The empty plan solves it
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard, which is already visited, so problem is trivial (you are at driveway - just observed)
        # Preserve goal structure for framework: Go to a not yet visited location if possible
        # Here, the observation is you are in the driveway, so goal is to visit any not-yet-visited location (none in universal knowledge, so goal is dummy: stay at driveway)
        return []


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and))
)

Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    warning: empty con/disjunction in domain definition. simplifying.


ff: goal can be simplified to TRUE. The empty plan solves it
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move south
You are in the driveway. To the North you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard, which is already visited, so problem is trivial (you are at driveway - just observed)
        # Preserve goal structure for framework: Go to a not yet visited location if possible
        # Here, the observation is you are in the driveway, so goal is to visit any not-yet-visited location (none in universal knowledge, so goal is dummy: stay at driveway)
        return []


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and))
)

### Planner Error from previous PDDL (if any)
                    ── SOLVER LOG ─────────────────────────────────
                    warning: empty con/disjunction in domain definition. simplifying.


ff: goal can be simplified to TRUE. The empty plan solves it
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard; the goal is to visit it.
        return [self.visited(self.roomObjs["backyard"])]


--- Attempting to Plan (Small Loop Try #3) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move south
You are in the driveway. To the North you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and))
)


### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    warning: empty con/disjunction in domain definition. simplifying.


ff: goal can be simplified to TRUE. The empty plan solves it
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard; the goal is to visit it.
        return [self.visited(self.roomObjs["backyard"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and (visited backyard)))
)

Actions from solver: ['move north'] 
Raw plan text: (MOVE DRIVEWAY BACKYARD NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 2 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-TO-DRIVEWAY
	#Actions: 2
	#Fluents: 3
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000108
Nodes generated during search: 2
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000108 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_e70r5q76/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_e70r5q76/plan_tmp.txt 1

Current action_queue: ['move north'] 
> move north 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 16==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepDriveway(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["driveway"]),
            self.visited(self.roomObjs["driveway"]),

            # driveway <-> backyard (north, door, open)
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"])
        ]

    @goal
    def goal(self):
        # The only unvisited room is backyard; the goal is to visit it.
        return [self.visited(self.roomObjs["backyard"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and (visited backyard)))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway", "kitchen", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),

            # backyard <-> driveway (south, door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),

            # backyard <-> kitchen (north, door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> street (east, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed door, unknown room)
            # Since we don't know the room to the west, do NOT add another room or adjacent relation yet.
            self.door_between(self.roomObjs["backyard"], self.roomObjs["?west_room"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["?west_room"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Of the rooms visible, kitchen and street are unvisited
        # Per instructions, set goal to visit an unvisited adjacent location (prefer kitchen since most natural)
        return [self.visited(self.roomObjs["kitchen"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-to-driveway)
  (:domain exploration)
  (:objects
    backyard driveway - location
    north south - direction
  )
  (:init
    (at driveway)
    (visited driveway)

    (adjacent driveway backyard north)
    (adjacent backyard driveway south)
    (door-between driveway backyard north)
    (door-between backyard driveway south)
    (door-open driveway backyard north)
    (door-open backyard driveway south)
  )
  (:goal (and (visited backyard)))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway", "kitchen", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),

            # backyard <-> driveway (south, door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),

            # backyard <-> kitchen (north, door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> street (east, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed door, unknown room)
            # Since we don't know the room to the west, do NOT add another room or adjacent relation yet.
            self.door_between(self.roomObjs["backyard"], self.roomObjs["?west_room"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["?west_room"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Of the rooms visible, kitchen and street are unvisited
        # Per instructions, set goal to visit an unvisited adjacent location (prefer kitchen since most natural)
        return [self.visited(self.roomObjs["kitchen"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-backyard)
  (:domain exploration)
  (:objects
    backyard driveway kitchen street unknown - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    
    ;; backyard <-> driveway (south, door, open)
    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)

    ;; backyard <-> kitchen (north, door, open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)

    ;; backyard <-> street (east, no door)
    (adjacent backyard street east)
    (adjacent street backyard west)

    ;; backyard <-> unknown (west, closed door)
    (door-between backyard unknown west)
    (door-closed backyard unknown west)
  )
  (:goal (and (visited kitchen)))
)

Actions from solver: ['move north'] 
Raw plan text: (MOVE BACKYARD KITCHEN NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 7 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-BACKYARD
	#Actions: 7
	#Fluents: 9
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 8.79999e-05
Nodes generated during search: 5
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 8.79999e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_v685b1yh/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_v685b1yh/plan_tmp.txt 1

Current action_queue: ['move north'] 
> move north 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry.  


====Step 17==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepBackyard(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "backyard", "driveway", "kitchen", "street"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["backyard"]),
            self.visited(self.roomObjs["backyard"]),

            # backyard <-> driveway (south, door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["driveway"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["driveway"], self.roomObjs["backyard"], self.dirObjs["north"]),

            # backyard <-> kitchen (north, door, open)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),

            # backyard <-> street (east, no door)
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["street"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["street"], self.roomObjs["backyard"], self.dirObjs["west"]),
            # backyard <-> ??? (west, closed door, unknown room)
            # Since we don't know the room to the west, do NOT add another room or adjacent relation yet.
            self.door_between(self.roomObjs["backyard"], self.roomObjs["?west_room"], self.dirObjs["west"]),
            self.door_closed(self.roomObjs["backyard"], self.roomObjs["?west_room"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Of the rooms visible, kitchen and street are unvisited
        # Per instructions, set goal to visit an unvisited adjacent location (prefer kitchen since most natural)
        return [self.visited(self.roomObjs["kitchen"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-backyard)
  (:domain exploration)
  (:objects
    backyard driveway kitchen street unknown - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    
    ;; backyard <-> driveway (south, door, open)
    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)

    ;; backyard <-> kitchen (north, door, open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)

    ;; backyard <-> street (east, no door)
    (adjacent backyard street east)
    (adjacent street backyard west)

    ;; backyard <-> unknown (west, closed door)
    (door-between backyard unknown west)
    (door-closed backyard unknown west)
  )
  (:goal (and (visited kitchen)))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry", "?south_room", "?west_room"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> backyard (south, open patio door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),

            # kitchen <-> pantry (west, open plain door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"])
        ]

    @goal
    def goal(self):
        # Must visit a location not yet visited: pantry (adjacent and unvisited)
        return [self.visited(self.roomObjs["pantry"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)
  
  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )
  
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-backyard)
  (:domain exploration)
  (:objects
    backyard driveway kitchen street unknown - location
    north south east west - direction
  )
  (:init
    (at backyard)
    (visited backyard)
    
    ;; backyard <-> driveway (south, door, open)
    (adjacent backyard driveway south)
    (adjacent driveway backyard north)
    (door-between backyard driveway south)
    (door-between driveway backyard north)
    (door-open backyard driveway south)
    (door-open driveway backyard north)

    ;; backyard <-> kitchen (north, door, open)
    (adjacent backyard kitchen north)
    (adjacent kitchen backyard south)
    (door-between backyard kitchen north)
    (door-between kitchen backyard south)
    (door-open backyard kitchen north)
    (door-open kitchen backyard south)

    ;; backyard <-> street (east, no door)
    (adjacent backyard street east)
    (adjacent street backyard west)

    ;; backyard <-> unknown (west, closed door)
    (door-between backyard unknown west)
    (door-closed backyard unknown west)
  )
  (:goal (and (visited kitchen)))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry", "?south_room", "?west_room"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> backyard (south, open patio door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),

            # kitchen <-> pantry (west, open plain door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"])
        ]

    @goal
    def goal(self):
        # Must visit a location not yet visited: pantry (adjacent and unvisited)
        return [self.visited(self.roomObjs["pantry"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard pantry ?south_room ?west_room - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    ;; kitchen <-> backyard (south, open patio door)
    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)

    ;; kitchen <-> pantry (west, open plain door)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (and (visited pantry)))
)

Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_1jq4zrvk/problem.pddl: syntax error in line 4, '?SOUTH_ROOM':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard pantry ?south_room ?west_room - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    ;; kitchen <-> backyard (south, open patio door)
    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)

    ;; kitchen <-> pantry (west, open plain door)
    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (and (visited pantry)))
)


### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_1jq4zrvk/problem.pddl: syntax error in line 4, '?SOUTH_ROOM':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry", "?south_room", "?west_room"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> backyard (south, open patio door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),

            # kitchen <-> pantry (west, open plain door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"])
        ]

    @goal
    def goal(self):
        # Must visit a location not yet visited: pantry (adjacent and unvisited)
        return [self.visited(self.roomObjs["pantry"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard pantry - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (and (visited pantry)))
)

Actions from solver: ['move west'] 
Raw plan text: (MOVE KITCHEN PANTRY WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-KITCHEN
	#Actions: 4
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 7.6e-05
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 7.6e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_b2l1pbzl/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_b2l1pbzl/plan_tmp.txt 1

Current action_queue: ['move west'] 
> move west 
 You are in the pantry. In one part of the room you see a folding chair, that has nothing on it. There is also a shelf, that has nothing on it. 
Through an open plain door, to the East you see the kitchen.  


====Step 18==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move north', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "backyard", "pantry", "?south_room", "?west_room"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> backyard (south, open patio door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),

            # kitchen <-> pantry (west, open plain door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"])
        ]

    @goal
    def goal(self):
        # Must visit a location not yet visited: pantry (adjacent and unvisited)
        return [self.visited(self.roomObjs["pantry"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[pf]
(define (problem step-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard pantry - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (and (visited pantry)))
)

### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),

            # pantry <-> kitchen (east, open plain door)
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Must go to a new (not visited) location; here: kitchen
        return [self.visited(self.roomObjs["kitchen"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move west
You are in the pantry. Through an open plain door, to the East you see the kitchen. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[Problem file]
(define (problem step-kitchen)
  (:domain exploration)
  (:objects
    kitchen backyard pantry - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (and (visited pantry)))
)


### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),

            # pantry <-> kitchen (east, open plain door)
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Must go to a new (not visited) location; here: kitchen
        return [self.visited(self.roomObjs["kitchen"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)

[PDDL pf]
(define (problem step-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (adjacent pantry kitchen east)
    (adjacent kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen pantry west)
    (door-open pantry kitchen east)
    (door-open kitchen pantry west)
  )
  (:goal (and (visited kitchen)))
)
Actions from solver: ['move east'] 
Raw plan text: (MOVE PANTRY KITCHEN EAST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 2 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-PANTRY
	#Actions: 2
	#Fluents: 3
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 9.90002e-05
Nodes generated during search: 2
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 9.90002e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_50p11_fw/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_50p11_fw/plan_tmp.txt 1

Current action_queue: ['move east'] 
> move east 
 You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry.  


====Step 19==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to west', 'move west', 'move east', 'open door to south', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move east', 'move west', 'move north', 'move west', 'move east', 'move south', 'move south', 'move north', 'move north', 'move west', 'move east'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


[py_problem]
from py2pddl import goal, init

class ExplorationStepPantry(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["pantry"]),
            self.visited(self.roomObjs["pantry"]),

            # pantry <-> kitchen (east, open plain door)
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"])
        ]

    @goal
    def goal(self):
        # Must go to a new (not visited) location; here: kitchen
        return [self.visited(self.roomObjs["kitchen"])]


### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)

[pf]
(define (problem step-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (adjacent pantry kitchen east)
    (adjacent kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen pantry west)
    (door-open pantry kitchen east)
    (door-open kitchen pantry west)
  )
  (:goal (and (visited kitchen)))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect

Generated py_problem:
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> backyard (south, open patio door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),

            # kitchen <-> pantry (west, open plain door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"])
        ]

    @goal
    def goal(self):
        # Must go to a new (not visited) location; here: backyard
        return [self.visited(self.roomObjs["backyard"])]


--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the kitchen. Through an open patio door, to the South you see the backyard. Through an open plain door, to the West you see the pantry. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)

[Problem file]
(define (problem step-pantry)
  (:domain exploration)
  (:objects
    kitchen pantry - location
    north south east west - direction
  )
  (:init
    (at pantry)
    (visited pantry)

    (adjacent pantry kitchen east)
    (adjacent kitchen pantry west)
    (door-between pantry kitchen east)
    (door-between kitchen pantry west)
    (door-open pantry kitchen east)
    (door-open kitchen pantry west)
  )
  (:goal (and (visited kitchen)))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Direction = create_type("Direction")

    @predicate(Room)
    def visited(self, room):
        """True iff the agent has visited the room."""

    @predicate(Room)
    def agent_at(self, room):
        """True iff the agent is in the given room."""

    @predicate(Room, Room, Direction)
    def adjacent(self, room_from, room_to, direction):
        """True iff room_to is adjacent to room_from in the given direction."""

    @predicate(Room, Room, Direction)
    def door_between(self, room_from, room_to, direction):
        """True iff there is a door between room_from and room_to in the given direction."""

    @predicate(Room, Room, Direction)
    def door_open(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is open."""

    @predicate(Room, Room, Direction)
    def door_closed(self, room_from, room_to, direction):
        """True iff the door between room_from and room_to in direction is closed."""

    @action(Room, Room, Direction)
    def move(self, room_from, room_to, direction):
        precond = [self.agent_at(room_from), self.adjacent(room_from, room_to, direction),
                   (~self.door_between(room_from, room_to, direction) | self.door_open(room_from, room_to, direction))]
        effect = [~self.agent_at(room_from), self.agent_at(room_to), self.visited(room_to)]
        return precond, effect

    @action(Room, Room, Direction)
    def open_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        effect = [~self.door_closed(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        return precond, effect

    @action(Room, Room, Direction)
    def close_door(self, room_from, room_to, direction):
        precond = [self.door_between(room_from, room_to, direction), self.door_open(room_from, room_to, direction)]
        effect = [~self.door_open(room_from, room_to, direction), self.door_closed(room_from, room_to, direction)]
        return precond, effect


### Python IR: problem class
from py2pddl import goal, init

class ExplorationStepKitchen(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs([
            "kitchen", "pantry", "backyard"
        ])
        self.dirObjs = ExplorationDomain.Direction.create_objs([
            "north", "south", "east", "west"
        ])

    @init
    def init(self):
        return [
            self.agent_at(self.roomObjs["kitchen"]),
            self.visited(self.roomObjs["kitchen"]),

            # kitchen <-> backyard (south, open patio door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.adjacent(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_between(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["backyard"], self.dirObjs["south"]),
            self.door_open(self.roomObjs["backyard"], self.roomObjs["kitchen"], self.dirObjs["north"]),

            # kitchen <-> pantry (west, open plain door)
            self.adjacent(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.adjacent(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_between(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_between(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"]),
            self.door_open(self.roomObjs["kitchen"], self.roomObjs["pantry"], self.dirObjs["west"]),
            self.door_open(self.roomObjs["pantry"], self.roomObjs["kitchen"], self.dirObjs["east"])
        ]

    @goal
    def goal(self):
        # Must go to a new (not visited) location; here: backyard
        return [self.visited(self.roomObjs["backyard"])]


Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:requirements :typing)
  (:types location direction)

  (:predicates
    (at ?loc - location)
    (visited ?loc - location)
    (adjacent ?loc1 - location ?loc2 - location ?dir - direction)
    (door-between ?loc1 - location ?loc2 - location ?dir - direction)
    (door-open ?loc1 - location ?loc2 - location ?dir - direction)
    (door-closed ?loc1 - location ?loc2 - location ?dir - direction)
  )

  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (door-between ?loc1 ?loc2 ?dir)
      (door-closed ?loc1 ?loc2 ?dir)
    )
    :effect (and
      (door-open ?loc1 ?loc2 ?dir)
      (not (door-closed ?loc1 ?loc2 ?dir))
    )
  )

  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (at ?from)
      (adjacent ?from ?to ?dir)
      (or (not (door-between ?from ?to ?dir)) (door-open ?from ?to ?dir))
    )
    :effect (and
      (not (at ?from))
      (at ?to)
      (visited ?to)
    )
  )
)


[PDDL pf]
(define (problem step-kitchen)
  (:domain exploration)
  (:objects
    kitchen pantry backyard - location
    north south east west - direction
  )
  (:init
    (at kitchen)
    (visited kitchen)

    (adjacent kitchen backyard south)
    (adjacent backyard kitchen north)
    (door-between kitchen backyard south)
    (door-between backyard kitchen north)
    (door-open kitchen backyard south)
    (door-open backyard kitchen north)

    (adjacent kitchen pantry west)
    (adjacent pantry kitchen east)
    (door-between kitchen pantry west)
    (door-between pantry kitchen east)
    (door-open kitchen pantry west)
    (door-open pantry kitchen east)
  )
  (:goal (and (visited backyard)))
)

Actions from solver: ['move south'] 
Raw plan text: (MOVE KITCHEN BACKYARD SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: STEP-KITCHEN
	#Actions: 4
	#Fluents: 5
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000132
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 0.000132 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_tkj0tz0w/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_tkj0tz0w/plan_tmp.txt 1

Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  
