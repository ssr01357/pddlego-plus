Observations: You are in the kitchen. In one part of the room you see a stove. There is also an oven. You also see a fridge that is closed. In another part of the room you see a counter, that has nothing on it. In one part of the room you see a kitchen cupboard that is closed. There is also a cutlery drawer that is closed. You also see a trash can that is closed. In another part of the room you see a dishwasher that is closed. In one part of the room you see a dining chair, that has nothing on it. 
To the South you see a closed patio door. To the West you see a closed plain door.  
Gold path: ['look around', 'open door to south', 'open door to west', 'move south', 'open door to west', 'move east', 'open door to north', 'move north', 'take coin'] 
Valid Actions: ['look around', 'close door to west', 'move west', 'open door to south', 'open door to west', 'inventory', 'move south', 'close door to south'] 
taskDescription: Your task is to search the environment and find the coin.  Once you find the coin, take it. 
brief_obs: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 
 


====Step 0==== 

----Larger Loop No. 0---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
N/A

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:types location direction door doortype)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_52oplxdl/problem.pddl: syntax error in line 3, ':TYPES':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:types location direction door doortype)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_52oplxdl/problem.pddl: syntax error in line 3, ':TYPES':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:types location direction door doortype)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_lw_le945/problem.pddl: syntax error in line 3, ':TYPES':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:types location direction door doortype)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
### Planner Error from previous PDDL (if any)
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_lw_le945/problem.pddl: syntax error in line 3, ':TYPES':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

--- Attempting to Plan (Small Loop Try #3) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:types location direction door doortype)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    /tmp/pddl_run_lw_le945/problem.pddl: syntax error in line 3, ':TYPES':
'define' expected
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOORAT. check input files
── VAL LOG ────────────────────────────────────
No validation log.


--- Attempting to Plan (Small Loop Try #4) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: look around
You are in the kitchen. To the South you see a closed patio door. To the West you see a closed plain door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOORAT. check input files
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction ?door - door)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction ?door - door)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: ['open door to south_door', 'move south_door'] 
Raw plan text: (OPEN-DOOR KITCHEN PATIO SOUTH SOUTH_DOOR)
(MOVE KITCHEN PATIO SOUTH SOUTH_DOOR)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 4
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.00014
Nodes generated during search: 5
Nodes expanded during search: 2
Plan found with cost: 2
Fast-BFS search completed in 0.00014 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_oq07f25s/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_oq07f25s/plan_tmp.txt 2

Current action_queue: ['open door to south_door', 'move south_door'] 
> open door to south_door 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south_door
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction ?door - door)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction ?door - door)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south_door
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction ?door - door)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction ?door - door)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (DoorAt ?dir ?from ?door)
      (DoorOpen ?door)
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOOROPEN. check input files
── VAL LOG ────────────────────────────────────
No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south_door
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOOROPEN. check input files
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?dir - direction ?door - door)
    :precondition (and
      (In ?loc1)
      (exists (?loc2 - location) (Connected ?loc1 ?dir ?loc2))
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: ['open door to south_door', 'move south'] 
Raw plan text: (OPEN-DOOR KITCHEN SOUTH SOUTH_DOOR)
(MOVE KITCHEN PATIO SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 4
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000143
Nodes generated during search: 6
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000143 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_nh4weuih/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_nh4weuih/plan_tmp.txt 2

Current action_queue: ['open door to south_door', 'move south'] 
> open door to south_door 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 2---- 
successful_actions: [] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south_door
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?dir - direction ?door - door)
    :precondition (and
      (In ?loc1)
      (exists (?loc2 - location) (Connected ?loc1 ?dir ?loc2))
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south_door
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?dir - direction ?door - door)
    :precondition (and
      (In ?loc1)
      (exists (?loc2 - location) (Connected ?loc1 ?dir ?loc2))
      (DoorAt ?dir ?loc1 ?door)
      (DoorClosed ?door)
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to south_door. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR KITCHEN PATIO SOUTH)
(MOVE KITCHEN PATIO SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 4 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 4
	#Fluents: 7
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000142
Nodes generated during search: 6
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000142 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_4jylfh_6/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_4jylfh_6/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the patio door, revealing the backyard.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the backyard. In one part of the room you see a barbeque. There is also a workbench, that has nothing on it. You also see a patio chair, that has nothing on it. In another part of the room you see a patio table, that has nothing on it. In one part of the room you see a clothes line, that has nothing on it. There is also a garden, that has nothing on it. 
Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door.  


====Step 1==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['patio']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorClosed(self.doorObjs['west_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['patio'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['backyard']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorOpen(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the patio door, revealing the backyard. 

Action: move south
You are in the backyard. Through an open patio door, to the North you see the kitchen. To the South you see the driveway. To the East you see the street. To the West you see a closed patio door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room - location
    south west - direction
    south_door west_door - door
    patio plain - doortype
  )
  (:init
    (In kitchen)
    (Connected kitchen south patio)
    (Connected kitchen west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorClosed south_door)
    (DoorClosed west_door)
  )
  (:goal (In patio))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['backyard']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorOpen(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street - location
    south west north east - direction
    south_door west_door west_backyard_door - door
    patio plain - doortype
  )
  (:init
    (In backyard)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorOpen south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
  )
  (:goal (In west_room))
)
Actions from solver: ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR BACKYARD WEST_ROOM WEST)
(MOVE BACKYARD WEST_ROOM WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 8 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 8
	#Fluents: 9
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000111
Nodes generated during search: 10
Nodes expanded during search: 5
Plan found with cost: 2
Fast-BFS search completed in 0.000111 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_zcq62va1/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_zcq62va1/plan_tmp.txt 2

Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the patio door, revealing the living room.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the living room. In one part of the room you see a wastepaper basket that is closed. There is also a book case, that has nothing on it. You also see a TV stand, that has nothing on it. In another part of the room you see a arm chair, that has nothing on it. In one part of the room you see a side table, that has nothing on it. There is also a coffee table, that has nothing on it. You also see a end table, that has nothing on it. In another part of the room you see a sofa, that has nothing on it. 
To the South you see a closed wood door. Through an open patio door, to the East you see the backyard.  


====Step 2==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
You open the patio door, revealing the living room. 

Action: move west
You are in the living room. To the South you see a closed wood door. Through an open patio door, to the East you see the backyard. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['backyard']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorOpen(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street - location
    south west north east - direction
    south_door west_door west_backyard_door - door
    patio plain - doortype
  )
  (:init
    (In backyard)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorOpen south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
  )
  (:goal (In west_room))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'south_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['living_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['south_room']),
            self.Connected(self.roomObjs['south_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_living_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['south_room'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
You open the patio door, revealing the living room. 

Action: move west
You are in the living room. To the South you see a closed wood door. Through an open patio door, to the East you see the backyard. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street - location
    south west north east - direction
    south_door west_door west_backyard_door - door
    patio plain - doortype
  )
  (:init
    (In backyard)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west west_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorOpen south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
  )
  (:goal (In west_room))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'south_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['living_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['south_room']),
            self.Connected(self.roomObjs['south_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_living_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['south_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room south_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door - door
    patio plain wood - doortype
  )
  (:init
    (In living_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south south_room)
    (Connected south_room north living_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorOpen south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed south_living_door)
  )
  (:goal (In south_room))
)
Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR LIVING_ROOM SOUTH_ROOM SOUTH)
(MOVE LIVING_ROOM SOUTH_ROOM SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 12 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 12
	#Fluents: 13
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000133
Nodes generated during search: 9
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000133 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_k1q4nr8p/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_k1q4nr8p/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the wood door, revealing the bathroom.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the bathroom. In one part of the room you see a dressing table, that has nothing on it. There is also a sink, that has nothing on it. You also see a wall hook, that has nothing on it. In another part of the room you see a bath mat. In one part of the room you see a toilet roll holder, that has nothing on it. There is also a towel rack, that has nothing on it. You also see a bath tub, that has nothing on it. In another part of the room you see a shower, that has nothing on it. In one part of the room you see a trash can that is closed. There is also a bathroom cabinet that is closed. You also see a toilet. 
Through an open wood door, to the North you see the living room. To the South you see a closed wood door. To the West you see a closed wood door.  


====Step 3==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the wood door, revealing the bathroom. 

Action: move south
You are in the bathroom. Through an open wood door, to the North you see the living room. To the South you see a closed wood door. To the West you see a closed wood door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'south_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['living_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['south_room']),
            self.Connected(self.roomObjs['south_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_living_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['south_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room south_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door - door
    patio plain wood - doortype
  )
  (:init
    (In living_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south south_room)
    (Connected south_room north living_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorOpen south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed south_living_door)
  )
  (:goal (In south_room))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['living_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bathroom'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the wood door, revealing the bathroom. 

Action: move south
You are in the bathroom. Through an open wood door, to the North you see the living room. To the South you see a closed wood door. To the West you see a closed wood door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room south_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door - door
    patio plain wood - doortype
  )
  (:init
    (In living_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south south_room)
    (Connected south_room north living_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorOpen south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed south_living_door)
  )
  (:goal (In south_room))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['living_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bathroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door - door
    patio plain wood - doortype
  )
  (:init
    (In living_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south bathroom)
    (Connected bathroom north living_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorClosed south_living_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed south_door)
  )
  (:goal (In bathroom))
)
Actions from solver: ['open door to south', 'move south'] 
Raw plan text: (OPEN-DOOR LIVING_ROOM BATHROOM SOUTH)
(MOVE LIVING_ROOM BATHROOM SOUTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 13 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 13
	#Fluents: 15
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000128
Nodes generated during search: 9
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000128 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_xdwque38/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_xdwque38/plan_tmp.txt 2

Current action_queue: ['open door to south', 'move south'] 
> open door to south 
 You open the wood door, revealing the laundry room.  
Small Loop, action_queue: ['move south'] 
Current action_queue: ['move south'] 
> move south 
 You are in the laundry room. In one part of the room you see a bench, that has nothing on it. There is also a work table, that has nothing on it. You also see a clothes drier that is closed. In another part of the room you see a laundry basket, that has nothing on it. In one part of the room you see a washing machine that is closed. 
Through an open wood door, to the North you see the bathroom.  


====Step 4==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to south
You open the wood door, revealing the laundry room. 

Action: move south
You are in the laundry room. Through an open wood door, to the North you see the bathroom. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['living_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bathroom'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door - door
    patio plain wood - doortype
  )
  (:init
    (In living_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south bathroom)
    (Connected bathroom north living_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorClosed south_living_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed south_door)
  )
  (:goal (In bathroom))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bathroom'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to south
You open the wood door, revealing the laundry room. 

Action: move south
You are in the laundry room. Through an open wood door, to the North you see the bathroom. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    ))
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door - door
    patio plain wood - doortype
  )
  (:init
    (In living_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south bathroom)
    (Connected bathroom north living_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorClosed south_living_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed south_door)
  )
  (:goal (In bathroom))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bathroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door - door
    patio plain wood - doortype
  )
  (:init
    (In laundry_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
  )
  (:goal (In bathroom))
)
Actions from solver: ['move north'] 
Raw plan text: (MOVE LAUNDRY_ROOM BATHROOM NORTH)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 14 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 14
	#Fluents: 14
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[0 / 0]--
--[0 / 1]--
Total time: 9.90002e-05
Nodes generated during search: 3
Nodes expanded during search: 1
Plan found with cost: 1
Fast-BFS search completed in 9.90002e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_10p529oj/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 1 

Successful plans:
Value: 1
 /tmp/pddl_run_10p529oj/plan_tmp.txt 1

Current action_queue: ['move north'] 
> move north 
 You are in the bathroom. In one part of the room you see a dressing table, that has nothing on it. There is also a sink, that has nothing on it. You also see a wall hook, that has nothing on it. In another part of the room you see a bath mat. In one part of the room you see a toilet roll holder, that has nothing on it. There is also a towel rack, that has nothing on it. You also see a bath tub, that has nothing on it. In another part of the room you see a shower, that has nothing on it. In one part of the room you see a trash can that is closed. There is also a bathroom cabinet that is closed. You also see a toilet. 
Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. To the West you see a closed wood door.  


====Step 5==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move north
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. To the West you see a closed wood door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bathroom'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door - door
    patio plain wood - doortype
  )
  (:init
    (In laundry_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
  )
  (:goal (In bathroom))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move north
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. To the West you see a closed wood door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door - door
    patio plain wood - doortype
  )
  (:init
    (In laundry_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
  )
  (:goal (In bathroom))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door - door
    patio plain wood - doortype
  )
  (:init
    (In bathroom)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
  )
  (:goal (In west_bathroom_room))
)
Actions from solver: ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR BATHROOM WEST_BATHROOM_ROOM WEST)
(MOVE BATHROOM WEST_BATHROOM_ROOM WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 17 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 17
	#Fluents: 17
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000112
Nodes generated during search: 6
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000112 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_b6pz8qp0/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_b6pz8qp0/plan_tmp.txt 2

Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the wood door, revealing the corridor.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the corridor. In one part of the room you see a key holder, that has nothing on it. There is also a shoe cabinet that is closed. You also see a umbrella stand, that has nothing on it. In another part of the room you see a hat rack, that has nothing on it. In one part of the room you see a coat hanger, that has nothing on it. 
Through an open wood door, to the East you see the bathroom. To the West you see a closed wood door.  


====Step 6==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
You open the wood door, revealing the corridor. 

Action: move west
You are in the corridor. Through an open wood door, to the East you see the bathroom. To the West you see a closed wood door. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door - door
    patio plain wood - doortype
  )
  (:init
    (In bathroom)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
  )
  (:goal (In west_bathroom_room))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorClosed(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
You open the wood door, revealing the corridor. 

Action: move west
You are in the corridor. Through an open wood door, to the East you see the bathroom. To the West you see a closed wood door. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door - door
    patio plain wood - doortype
  )
  (:init
    (In bathroom)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
  )
  (:goal (In west_bathroom_room))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorClosed(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In corridor)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorClosed west_corridor_door)
  )
  (:goal (In west_room))
)
Actions from solver: ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR CORRIDOR WEST_ROOM WEST)
(MOVE CORRIDOR WEST_ROOM WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 21 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 21
	#Fluents: 20
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 0.000134
Nodes generated during search: 7
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 0.000134 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_846uti2e/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_846uti2e/plan_tmp.txt 2

Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 You open the wood door, revealing the bedroom.  
Small Loop, action_queue: ['move west'] 
Current action_queue: ['move west'] 
> move west 
 You are in the bedroom. In one part of the room you see a dressing table, that has nothing on it. There is also a desk chair, that has nothing on it. You also see a desk, that has nothing on it. In another part of the room you see a chest of drawers that is closed. In one part of the room you see a wardrobe that is closed. There is also a night stand, that has nothing on it. You also see a bed, that has nothing on it. 
Through an open wood door, to the East you see the corridor.  


====Step 7==== 

----Larger Loop No. 0---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
You open the wood door, revealing the bedroom. 

Action: move west
You are in the bedroom. Through an open wood door, to the East you see the corridor. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorClosed(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In corridor)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorClosed west_corridor_door)
  )
  (:goal (In west_room))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
N/A

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
You open the wood door, revealing the bedroom. 

Action: move west
You are in the bedroom. Through an open wood door, to the East you see the corridor. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In corridor)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorClosed west_corridor_door)
  )
  (:goal (In west_room))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
N/A

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In corridor)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorClosed west_corridor_door)
  )
  (:goal (In west_room))
)
Actions from solver: ['open door to west', 'move west'] 
Raw plan text: (OPEN-DOOR CORRIDOR WEST_ROOM WEST)
(MOVE CORRIDOR WEST_ROOM WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 21 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 21
	#Fluents: 20
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[0 / 0]--
--[0 / 2]--
Total time: 9.4e-05
Nodes generated during search: 7
Nodes expanded during search: 3
Plan found with cost: 2
Fast-BFS search completed in 9.4e-05 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_o83m4c52/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 2 

Successful plans:
Value: 2
 /tmp/pddl_run_o83m4c52/plan_tmp.txt 2

Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 Unknown action: I'm not sure what you mean. 
Large loop error message: This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.
 

----Larger Loop No. 1---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In corridor)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorClosed west_corridor_door)
  )
  (:goal (In west_room))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In corridor)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorClosed west_corridor_door)
  )
  (:goal (In west_room))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to FALSE. No plan will solve it
── VAL LOG ────────────────────────────────────
No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
          (and (not (DoorClosed ?door)) (DoorOpen ?door)))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to FALSE. No plan will solve it
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (when (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
        (and (not (DoorClosed ?door)) (DoorOpen ?door))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOORCLOSED. check input files
── VAL LOG ────────────────────────────────────
No validation log.

[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: open door to west
Unknown action: I'm not sure what you mean.

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            (not exists(door, self.DoorAt(direction, fromRoom, door))) 
            or (exists(door, self.DoorAt(direction, fromRoom, door) and self.DoorOpen(door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (when (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
        (and (not (DoorClosed ?door)) (DoorOpen ?door))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)
### Planner Error from previous PDDL (if any)
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOORCLOSED. check input files
── VAL LOG ────────────────────────────────────
No validation log.

### Environment feedback from previous action (if any)
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

--- Attempting to Plan (Small Loop Try #3) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (when (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
        (and (not (DoorClosed ?door)) (DoorOpen ?door))
      )
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOORCLOSED. check input files
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to FALSE. No plan will solve it
── VAL LOG ────────────────────────────────────
No validation log.


--- Attempting to Plan (Small Loop Try #4) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: open door to west
Unknown action: I'm not sure what you mean.


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected backyard east street)
    (Connected kitchen west west_room)
    (Connected backyard west living_room)
    (Connected living_room west backyard)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west west_room)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
ff: goal can be simplified to FALSE. No plan will solve it
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. When you try to open door, there is no door here or there is nothing in this direction. If there is no door, you can directly move to that direction.


### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected driveway north backyard)
    (Connected backyard east street)
    (Connected street west backyard)
    (Connected kitchen west west_room)
    (Connected west_room east kitchen)
    (Connected backyard west living_room)
    (Connected living_room east backyard)
    (Connected living_room west backyard)
    (Connected backyard east living_room)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west bathroom)
    (Connected corridor west west_room)
    (Connected west_room east corridor)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)
Actions from solver: ['move east', 'move east', 'open door to west', 'move west'] 
Raw plan text: (MOVE WEST_ROOM CORRIDOR EAST)
(MOVE CORRIDOR BATHROOM EAST)
(OPEN-DOOR BATHROOM WEST_BATHROOM_ROOM WEST)
(MOVE BATHROOM WEST_BATHROOM_ROOM WEST)
 
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    task contains conditional effects. turning off state domination.

 --- OK.
 Match tree built with 27 nodes.

PDDL problem description loaded: 
	Domain: EXPLORATION
	Problem: EXPLORATION-PROBLEM
	#Actions: 27
	#Fluents: 18
Goals found: 1
Goals_Edges found: 1
Starting search with 1-BFWS...
--[1 / 0]--
--[1 / 1]--
--[1 / 2]--
--[1 / 3]--
--[0 / 0]--
--[0 / 4]--
Total time: 0.000176
Nodes generated during search: 14
Nodes expanded during search: 7
Plan found with cost: 4
Fast-BFS search completed in 0.000176 secs
                    ── VAL LOG ────────────────────────────────────
                    Checking plan: /tmp/pddl_run_bmrxt4yc/plan_tmp.txt
Plan executed successfully - checking goal
Plan valid
Final value: 4 

Successful plans:
Value: 4
 /tmp/pddl_run_bmrxt4yc/plan_tmp.txt 4

Current action_queue: ['move east', 'move east', 'open door to west', 'move west'] 
> move east 
 You are in the corridor. In one part of the room you see a key holder, that has nothing on it. There is also a shoe cabinet that is closed. You also see a umbrella stand, that has nothing on it. In another part of the room you see a hat rack, that has nothing on it. In one part of the room you see a coat hanger, that has nothing on it. 
Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom.  
Small Loop, action_queue: ['move east', 'open door to west', 'move west'] 
Current action_queue: ['move east', 'open door to west', 'move west'] 
> move east 
 You are in the bathroom. In one part of the room you see a dressing table, that has nothing on it. There is also a sink, that has nothing on it. You also see a wall hook, that has nothing on it. In another part of the room you see a bath mat. In one part of the room you see a toilet roll holder, that has nothing on it. There is also a towel rack, that has nothing on it. You also see a bath tub, that has nothing on it. In another part of the room you see a shower, that has nothing on it. In one part of the room you see a trash can that is closed. There is also a bathroom cabinet that is closed. You also see a toilet. 
Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor.  
Small Loop, action_queue: ['open door to west', 'move west'] 
Current action_queue: ['open door to west', 'move west'] 
> open door to west 
 That is already open.  
Large loop error message: This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct. 

----Larger Loop No. 2---- 
successful_actions: ['open door to south', 'move south', 'open door to west', 'move west', 'open door to south', 'move south', 'open door to south', 'move south', 'move north', 'open door to west', 'move west', 'open door to west', 'move west'] 
Small Loop, action_queue: [] 
[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['kitchen', 'patio', 'west_room', 'backyard', 'driveway', 'street', 'living_room', 'bathroom', 'laundry_room', 'west_bathroom_room', 'corridor'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['south_door', 'west_door', 'west_backyard_door', 'south_living_door', 'north_laundry_door', 'west_bathroom_door', 'west_corridor_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['patio', 'plain', 'wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['south', 'west', 'north', 'east'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['west_room']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['south'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['north'], self.roomObjs['kitchen']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['south'], self.roomObjs['driveway']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['east'], self.roomObjs['street']),
            self.Connected(self.roomObjs['kitchen'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['backyard'], self.directionObjs['west'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['west'], self.roomObjs['backyard']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['west_bathroom_room']),
            self.Connected(self.roomObjs['west_bathroom_room'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['west_room']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['kitchen'], self.doorObjs['south_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['kitchen'], self.doorObjs['west_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['backyard'], self.doorObjs['west_backyard_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['south_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['north_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['west_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['west_corridor_door']),
            self.DoorType(self.doorObjs['south_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['west_door'], self.doorTypeObjs['plain']),
            self.DoorType(self.doorObjs['west_backyard_door'], self.doorTypeObjs['patio']),
            self.DoorType(self.doorObjs['south_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['north_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['west_corridor_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['south_living_door']),
            self.DoorOpen(self.doorObjs['north_laundry_door']),
            self.DoorClosed(self.doorObjs['south_door']),
            self.DoorClosed(self.doorObjs['west_door']),
            self.DoorClosed(self.doorObjs['west_backyard_door']),
            self.DoorClosed(self.doorObjs['west_bathroom_door']),
            self.DoorOpen(self.doorObjs['west_corridor_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['west_bathroom_room'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected driveway north backyard)
    (Connected backyard east street)
    (Connected street west backyard)
    (Connected kitchen west west_room)
    (Connected west_room east kitchen)
    (Connected backyard west living_room)
    (Connected living_room east backyard)
    (Connected living_room west backyard)
    (Connected backyard east living_room)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west bathroom)
    (Connected corridor west west_room)
    (Connected west_room east corridor)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)
### Planner Error from previous PDDL (if any)
N/A
### Environment feedback from previous action (if any)
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

--- Attempting to Plan (Small Loop Try #1) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction door doortype)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    kitchen patio west_room backyard driveway street living_room bathroom laundry_room west_bathroom_room corridor - location
    south west north east - direction
    south_door west_door west_backyard_door south_living_door north_laundry_door west_bathroom_door west_corridor_door - door
    patio plain wood - doortype
  )
  (:init
    (In west_room)
    (Connected kitchen south backyard)
    (Connected backyard north kitchen)
    (Connected backyard south driveway)
    (Connected driveway north backyard)
    (Connected backyard east street)
    (Connected street west backyard)
    (Connected kitchen west west_room)
    (Connected west_room east kitchen)
    (Connected backyard west living_room)
    (Connected living_room east backyard)
    (Connected living_room west backyard)
    (Connected backyard east living_room)
    (Connected living_room south laundry_room)
    (Connected laundry_room north living_room)
    (Connected laundry_room north bathroom)
    (Connected bathroom south laundry_room)
    (Connected bathroom west west_bathroom_room)
    (Connected west_bathroom_room east bathroom)
    (Connected bathroom east corridor)
    (Connected corridor west bathroom)
    (Connected corridor west west_room)
    (Connected west_room east corridor)
    (Connected corridor east bathroom)
    (DoorAt south kitchen south_door)
    (DoorAt west kitchen west_door)
    (DoorAt west backyard west_backyard_door)
    (DoorAt south living_room south_living_door)
    (DoorAt north laundry_room north_laundry_door)
    (DoorAt west bathroom west_bathroom_door)
    (DoorAt west corridor west_corridor_door)
    (DoorType south_door patio)
    (DoorType west_door plain)
    (DoorType west_backyard_door patio)
    (DoorType south_living_door wood)
    (DoorType north_laundry_door wood)
    (DoorType west_bathroom_door wood)
    (DoorType west_corridor_door wood)
    (DoorOpen south_living_door)
    (DoorOpen north_laundry_door)
    (DoorClosed south_door)
    (DoorClosed west_door)
    (DoorClosed west_backyard_door)
    (DoorClosed west_bathroom_door)
    (DoorOpen west_corridor_door)
  )
  (:goal (In west_bathroom_room))
)

### (Optional) Planner/validator feedback to fix
N/A

### (Optional) Environment feedback to fix
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


--- Attempting to Plan (Small Loop Try #2) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)

### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            Forall(self.Door, (self.DoorAt(direction, fromRoom, self.Door) >> self.DoorOpen(self.Door)))
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)
### Planner Error from previous PDDL (if any)
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

### Environment feedback from previous action (if any)
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

--- Attempting to Plan (Small Loop Try #3) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
        (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
            (and (not (DoorClosed ?door)) (DoorOpen ?door))
        )
      )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)

### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOOROPEN. check input files
── VAL LOG ────────────────────────────────────
No validation log.


--- Attempting to Plan (Small Loop Try #4) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (and
      (not (DoorClosed ?door))
      (DoorOpen ?door)
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)

### (Optional) Planner/validator feedback to fix
── SOLVER LOG ─────────────────────────────────
undeclared variable ?DOOR in literal DOOROPEN. check input files
── VAL LOG ────────────────────────────────────
No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
              (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
                    (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)


[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)

Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

[PyIR Prompt] 
You will be given a natural language domain description and problem description.
Your task is to generate a Python representation of Planning Domain Definition Language (PDDL) — one domain class and one problem class — using a simple, class-based intermediate representation (IR). 
Python representation of PDDL domain file contains domain name, requirements, types of objects in the domain, predicates, and actions.
Based on the natural language domain description, identify the actions that are possible.
Identify action sematics i.e. understand the preconditions under which that action could be done and the effects of the action.
Then identify appropriate predicates that could enable action semantics i.e. preconditions and effects.
Python representation of PDDL domain file has a definitive syntax that must be followed for any domain. An abstract example is given below:

In the following Python domain file, the example class DomainName has been created. Its structure is similar to how a PDDL domain should be defined.

Name of the domain is the name of the Python class (DomainName).
Types are defined as class variables at the top (Type1, Type2).
Predicates are defined as instance methods decorated with @predicate.
Actions are defined as instance methods decorated with @action

The positional arguments of @predicate and @action decorators are the types of the respective arguments.
Methods decorated with @predicate should have empty bodies.
Methods decorated with @action return a tuple of two lists

<domain_file>
# imports stays exactly same for all domain files
# this python code should be executed without any python syntax errors
from py2pddl import Domain, create_type
from py2pddl import predicate, action

class DomainName(Domain):
	# let's think step by step and correctly define all the aspects of a domain file
	# making sure that the list of types, predicates, and actions comprehensively define the give domain
    Type1 = create_type("Type1")
    Type2 = create_type("Type2")

	# making sure that all the predicates needed are defined below
	# predicates have all the arguments needed along with the types
    # let's not have two predicates with the same name
    # let's make sure two arguments of a predicate function doesn't have same names. That would be a python syntax error.
    @predicate(Type1, Type2)
    def predicate1(self, arg1, arg2):
        """Complete the method signature and specify
        the respective types in the decorator"""

    @predicate(Type1)
    def predicate2(self, arg1):
        """Complete the method signature and specify
        the respective types in the decorator"""

	# let's define a list of actions that comprehensively define the given domain
	# the names for actions are always given precisely in the domain description, using only those actions
	# making sure that each action is defined with :parameters where every arguments needed for preconditions and effects are specified

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure preconditions is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure effects is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1, Type2, Type2)
    def action1(self, arg1, arg2, arg3):
        precond = [self.predicate1(arg1, arg3), self.predicate2(arg1)]
        effect = [~self.predicate1(arg1, arg2), self.predicate2(arg3)]
        return precond, effect

	# writing the definition of action1 which is one of the action given in domain description
	# first defining all the parameters needed for predicates in preconditions and effects
	# making sure :precondition is logically correct and aligns with the pre-conditions where action1 could be performed
	# making sure :effect is logically correct and aligns with the post-conditions or results of action being performed
    @action(Type1)
    def action2(self, arg1):
        precond = [self.predicate2(arg1)]
        effect = [~self.predicate2(arg1)]
        return precond, effect
</domain_file>

Notes for generating domain file: 
- the above example file is only for understanding the syntax
- type1 & type2 are only representative and should be replaced with appropriate types. There could be any number of types.
- predicate1 & predicate2 are only representative and should be replaced with appropriate predicates. There could be any number of predicates.
- action1 & action2 are only representative and should be replaced with appropriate actions. There could be any number of actions.
- arg1 & arg2 are only representative and should be replaced with appropriate arguments for predicates and in preconditions and effects.
- Use predicates with arguments of the right type as declared in domain file
- All the arguments to any :precondition or :effect of an action should be declared in :parameters as input arguments
- Verify and reason about correctness by reiterating the reasoning behind different predicates and actions




Python representation of PDDL problem file contains problem name, domain name, objects in this problem instance, init state of objects, and goal state of objects.
Based on the natural language problem description, identify the relevant objects for this problems with their names and types.
Represent the initial state with the appropriate predicates and object arguments. Represent the goal state with the appropriate predicates and object arguments.
Python representation of PDDL problem file has a definitive syntax that must be followed for any problem. An abstract example is given below.

<problem_file>
# imports stays the same for all problem files
# Assume DomainName is declared just before the problem file
# this python code should be executed correctly without any syntax errors
from py2pddl import goal, init

# let's define all the aspects of a problem file below starting with domain, objects, init state, and goal state

class ProblemName(DomainName):
	# making sure of defining all the objects that are required to define init state and goal state
    # defining the objects with a list of strings will generate a dict and the object should be retrieve as a dict as in the example below in goal function
    def __init__(self):
        super().__init__()
        self.type1Objs = DomainName.Type1.create_objs([1, 2], prefix="type1Obj")
        self.type2Objs = DomainName.Type2.create_objs(["type2Obj1", "type2Obj2"])

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @init
    def init(self):
        at = [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj1"]),
              self.predicate2(self.type1Objs[1]),]
        return at

	# reasoning about the validity of init state that captures the properties of objects in the initial state
	# defining the correct init state that represent the problem file below
    # let's index correctly for lists and dicts
    @goal
    def goal(self):
        return [self.predicate1(self.type1Objs[1], self.type2Objs["type2Obj2"]),
                self.predicate2(self.type1Objs[2])]
</problem_file>

Notes for generating problem file:
- No need to import DomainName for python problem file. Python Domain file and python problem file would be merged and executed.
- type1Objs, type2Oobjs, ... are only representative and should be replaced with appropriate objects. There could be any number of obects with their types.
- init state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define init state
- goal state with predicate1 & predicate2 is only representative and should be replaced with appropriate predicates that define goal state
- Use predicates with arguments of the right type as declared in domain file
- All the objects that would be arguments of predicates in init and goal states should be declared in __init__


Here is the natural language description of the domain and problem:

You are in an environment that you explore step by step. You must build and update the Python Representation of PDDL files of the environment based on only your observations.
Do not create something not appeared in the observations and also do not miss any observations e.g. through closed doors you may assume a room behind.
Do not assume that there will be a door connecting rooms.
Your task is always to keep exploration and go to a location you have not visited yet.
In other words, your goal should go to other not visited location.
Here are your current observations: Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 

Here are some valid actions you can take: ['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

Return output in strict JSON with two fields only, no extra text:
{
  "py_domain": "<python code for the domain class that represents the PDDL domain>",
  "py_problem": "<python code for the problem class that represents the PDDL problem>"
}

        ### Previous IR and PDDL history:
        ### Previous Python IR (edit minimally if possible)
[py_domain]
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room, Door)
    def Move(self, direction, fromRoom, toRoom, door):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            self.DoorAt(direction, fromRoom, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def OpenDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorClosed(door)
        ]
        effect = [
            ~self.DoorClosed(door),
            self.DoorOpen(door)
        ]
        return precond, effect

    @action(Direction, Room, Door)
    def CloseDoor(self, direction, room, door):
        precond = [
            self.In(room),
            self.DoorAt(direction, room, door),
            self.DoorOpen(door)
        ]
        effect = [
            ~self.DoorOpen(door),
            self.DoorClosed(door)
        ]
        return precond, effect

[py_problem]
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

### Previous PDDL (generated from the IR)
[df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
              (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
                    (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)


[pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)

### Planner Error from previous PDDL (if any)
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

### Environment feedback from previous action (if any)
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

        ### End of history.

        Now, based on the above history and your current observation, update the Python representation of PDDL files. 
        
Generated py_domain:
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall, When, exists

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            exists(self.Door, [
                self.DoorAt(direction, fromRoom, self.Door),
                self.DoorOpen(self.Door)
            ])
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room)
    def OpenDoor(self, direction, room):
        precond = [
            self.In(room),
            exists(self.Door, [
                self.DoorAt(direction, room, self.Door),
                self.DoorClosed(self.Door)
            ])
        ]
        effect = Forall(
            self.Door,
            When([
                self.DoorAt(direction, room, self.Door),
                self.DoorClosed(self.Door)
            ], [
                ~self.DoorClosed(self.Door),
                self.DoorOpen(self.Door)
            ])
        )
        return precond, effect

    @action(Direction, Room)
    def CloseDoor(self, direction, room):
        precond = [
            self.In(room),
            exists(self.Door, [
                self.DoorAt(direction, room, self.Door),
                self.DoorOpen(self.Door)
            ])
        ]
        effect = Forall(
            self.Door,
            When([
                self.DoorAt(direction, room, self.Door),
                self.DoorOpen(self.Door)
            ], [
                ~self.DoorOpen(self.Door),
                self.DoorClosed(self.Door)
            ])
        )
        return precond, effect
Generated py_problem:
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

--- Attempting to Plan (Small Loop Try #5) ---
[IR→PDDL Prompt] 
You will be given a class-based Python IR for a PDDL domain (one domain class) and a PDDL problem instance (one problem class),
plus the current observations and valid actions. Convert that IR into syntactically correct and mutually consistent PDDL.

### Hard constraints (must follow exactly)
- Declare EXACTLY these two actions with these names and parameter orders:
  1) :action open-door
     :parameters (?loc1 - location ?loc2 - location ?dir - direction)
  2) :action move
     :parameters (?from - location ?to - location ?dir - direction)
- Use typed PDDL (declare `location` and `direction` in :types).
- In problem file's init, you shouldn't have "not ()" but only the single status.
- The goal must be ground (e.g., (at loc_2)), never (at ?l) or quantifiers.
- Keep edits minimal if previous PDDL is provided.

### Current observations
Action: move east
You are in the corridor. Through an open wood door, to the East you see the bathroom. Through an open wood door, to the West you see the bedroom. 

Action: move east
You are in the bathroom. Through an open wood door, to the North you see the living room. Through an open wood door, to the South you see the laundry room. Through an open wood door, to the West you see the corridor. 

Action: open door to west
That is already open. 


### Valid actions
['close door to south', 'close door to west', 'move south', 'move west', 'open door to south', 'open door to west']

### (Optional) Previous PDDL (use as base with minimal fixes)
[Domain file]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
              (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
                    (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)


[Problem file]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)


### (Optional) Planner/validator feedback to fix
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.


### (Optional) Environment feedback to fix
This is the action you take: open door to west. You try to open a door that is already open. You already visited here. Make sure the status of door is correct.

### Python IR: domain class
from py2pddl import Domain, create_type
from py2pddl import predicate, action
from py2pddl.logic import Forall, When, exists

class ExplorationDomain(Domain):
    Room = create_type("Room")
    Door = create_type("Door")
    DoorType = create_type("DoorType")
    Direction = create_type("Direction")

    @predicate(Room)
    def In(self, room):
        """Agent is located in a room"""
        pass

    @predicate(Room, Direction, Room)
    def Connected(self, room1, direction, room2):
        """Rooms are connected via a door in a direction"""
        pass

    @predicate(Direction, Room, Door)
    def DoorAt(self, direction, room, door):
        """A door exists in a direction from a room"""
        pass

    @predicate(Door, DoorType)
    def DoorType(self, door, doorType):
        """Door has a specific type (patio/plain)"""
        pass

    @predicate(Door)
    def DoorClosed(self, door):
        """Door is closed"""
        pass

    @predicate(Door)
    def DoorOpen(self, door):
        """Door is open"""
        pass

    @action(Direction, Room, Room)
    def Move(self, direction, fromRoom, toRoom):
        precond = [
            self.In(fromRoom),
            self.Connected(fromRoom, direction, toRoom),
            exists(self.Door, [
                self.DoorAt(direction, fromRoom, self.Door),
                self.DoorOpen(self.Door)
            ])
        ]
        effect = [
            ~self.In(fromRoom),
            self.In(toRoom)
        ]
        return precond, effect

    @action(Direction, Room)
    def OpenDoor(self, direction, room):
        precond = [
            self.In(room),
            exists(self.Door, [
                self.DoorAt(direction, room, self.Door),
                self.DoorClosed(self.Door)
            ])
        ]
        effect = Forall(
            self.Door,
            When([
                self.DoorAt(direction, room, self.Door),
                self.DoorClosed(self.Door)
            ], [
                ~self.DoorClosed(self.Door),
                self.DoorOpen(self.Door)
            ])
        )
        return precond, effect

    @action(Direction, Room)
    def CloseDoor(self, direction, room):
        precond = [
            self.In(room),
            exists(self.Door, [
                self.DoorAt(direction, room, self.Door),
                self.DoorOpen(self.Door)
            ])
        ]
        effect = Forall(
            self.Door,
            When([
                self.DoorAt(direction, room, self.Door),
                self.DoorOpen(self.Door)
            ], [
                ~self.DoorOpen(self.Door),
                self.DoorClosed(self.Door)
            ])
        )
        return precond, effect

### Python IR: problem class
from py2pddl import goal, init

class ExplorationProblem(ExplorationDomain):
    def __init__(self):
        super().__init__()
        self.roomObjs = ExplorationDomain.Room.create_objs(['corridor', 'bathroom', 'bedroom', 'living_room', 'laundry_room'], prefix="room")
        self.doorObjs = ExplorationDomain.Door.create_objs(['corridor_east_bathroom_door', 'corridor_west_bedroom_door', 'bathroom_north_living_door', 'bathroom_south_laundry_door'], prefix="door")
        self.doorTypeObjs = ExplorationDomain.DoorType.create_objs(['wood'], prefix="doorType")
        self.directionObjs = ExplorationDomain.Direction.create_objs(['east', 'west', 'north', 'south'], prefix="direction")

    @init
    def init(self):
        return [
            self.In(self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['east'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['west'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['corridor'], self.directionObjs['west'], self.roomObjs['bedroom']),
            self.Connected(self.roomObjs['bedroom'], self.directionObjs['east'], self.roomObjs['corridor']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['north'], self.roomObjs['living_room']),
            self.Connected(self.roomObjs['living_room'], self.directionObjs['south'], self.roomObjs['bathroom']),
            self.Connected(self.roomObjs['bathroom'], self.directionObjs['south'], self.roomObjs['laundry_room']),
            self.Connected(self.roomObjs['laundry_room'], self.directionObjs['north'], self.roomObjs['bathroom']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['corridor'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['corridor'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['bathroom'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['bathroom'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorAt(self.directionObjs['west'], self.roomObjs['bathroom'], self.doorObjs['corridor_east_bathroom_door']),
            self.DoorAt(self.directionObjs['east'], self.roomObjs['bedroom'], self.doorObjs['corridor_west_bedroom_door']),
            self.DoorAt(self.directionObjs['south'], self.roomObjs['living_room'], self.doorObjs['bathroom_north_living_door']),
            self.DoorAt(self.directionObjs['north'], self.roomObjs['laundry_room'], self.doorObjs['bathroom_south_laundry_door']),
            self.DoorType(self.doorObjs['corridor_east_bathroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['corridor_west_bedroom_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_north_living_door'], self.doorTypeObjs['wood']),
            self.DoorType(self.doorObjs['bathroom_south_laundry_door'], self.doorTypeObjs['wood']),
            self.DoorOpen(self.doorObjs['corridor_east_bathroom_door']),
            self.DoorOpen(self.doorObjs['corridor_west_bedroom_door']),
            self.DoorOpen(self.doorObjs['bathroom_north_living_door']),
            self.DoorOpen(self.doorObjs['bathroom_south_laundry_door'])
        ]

    @goal
    def goal(self):
        return [self.In(self.roomObjs['bedroom'])]

Return output in STRICT JSON with two keys only, no extra commentary:
{
  "df": "<PDDL domain file text>",
  "pf": "<PDDL problem file text>"
}
 
[PDDL df]
(define (domain exploration)
  (:types location direction)
  (:predicates
    (In ?l - location)
    (Connected ?l1 - location ?d - direction ?l2 - location)
    (DoorAt ?d - direction ?l - location ?door - door)
    (DoorType ?door - door ?type - doortype)
    (DoorClosed ?door - door)
    (DoorOpen ?door - door)
  )
  (:action open-door
    :parameters (?loc1 - location ?loc2 - location ?dir - direction)
    :precondition (and
      (In ?loc1)
      (Connected ?loc1 ?dir ?loc2)
      (exists (?door - door) (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door)))
    )
    :effect (forall (?door - door)
              (when (and (DoorAt ?dir ?loc1 ?door) (DoorClosed ?door))
                    (and (not (DoorClosed ?door)) (DoorOpen ?door)))
    )
  )
  (:action move
    :parameters (?from - location ?to - location ?dir - direction)
    :precondition (and
      (In ?from)
      (Connected ?from ?dir ?to)
      (or 
        (not (exists (?door - door) (DoorAt ?dir ?from ?door)))
        (exists (?door - door) (and (DoorAt ?dir ?from ?door) (DoorOpen ?door)))
      )
    )
    :effect (and
      (not (In ?from))
      (In ?to)
    )
  )
)

[PDDL pf]
(define (problem exploration-problem)
  (:domain exploration)
  (:objects
    corridor bathroom bedroom living_room laundry_room - location
    east west north south - direction
    corridor_east_bathroom_door corridor_west_bedroom_door bathroom_north_living_door bathroom_south_laundry_door - door
    wood - doortype
  )
  (:init
    (In corridor)
    (Connected corridor east bathroom)
    (Connected bathroom west corridor)
    (Connected corridor west bedroom)
    (Connected bedroom east corridor)
    (Connected bathroom north living_room)
    (Connected living_room south bathroom)
    (Connected bathroom south laundry_room)
    (Connected laundry_room north bathroom)
    (DoorAt east corridor corridor_east_bathroom_door)
    (DoorAt west corridor corridor_west_bedroom_door)
    (DoorAt north bathroom bathroom_north_living_door)
    (DoorAt south bathroom bathroom_south_laundry_door)
    (DoorAt west bathroom corridor_east_bathroom_door)
    (DoorAt east bedroom corridor_west_bedroom_door)
    (DoorAt south living_room bathroom_north_living_door)
    (DoorAt north laundry_room bathroom_south_laundry_door)
    (DoorType corridor_east_bathroom_door wood)
    (DoorType corridor_west_bedroom_door wood)
    (DoorType bathroom_north_living_door wood)
    (DoorType bathroom_south_laundry_door wood)
    (DoorOpen corridor_east_bathroom_door)
    (DoorOpen corridor_west_bedroom_door)
    (DoorOpen bathroom_north_living_door)
    (DoorOpen bathroom_south_laundry_door)
  )
  (:goal (In bedroom))
)
Actions from solver: None 
Raw plan text:  
Solver stderr:
                    ── SOLVER LOG ─────────────────────────────────
                    malloc_consolidate(): invalid chunk size
Aborted (core dumped)
                    ── VAL LOG ────────────────────────────────────
                    No validation log.

